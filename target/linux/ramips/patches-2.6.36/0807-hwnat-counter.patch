Index: linux-2.6.36/net/nat/hw_nat/Kconfig
===================================================================
--- linux-2.6.36.orig/net/nat/hw_nat/Kconfig	2014-03-28 15:00:47.302531591 +0800
+++ linux-2.6.36/net/nat/hw_nat/Kconfig	2014-03-28 15:00:47.542531591 +0800
@@ -361,4 +361,9 @@
 #config  RA_HW_NAT_PPTP_L2TP
 #	bool "PPTP_L2TP Acceleration"
 #	depends on RA_HW_NAT && HNAT_V2 && RALINK_MT7620
+config RA_HW_NAT_ACCNT_MAINTAINER
+	bool "byte/pkt count for LAN/WAN port"
+	depends on RA_HW_NAT && HNAT_V2
+	help
+	"if you need 64bits bytes/pkts counter, and ask HNAT module to get statistic counter periodically, please enable it"
 
Index: linux-2.6.36/net/nat/hw_nat/Makefile
===================================================================
--- linux-2.6.36.orig/net/nat/hw_nat/Makefile	2014-03-28 15:00:47.302531591 +0800
+++ linux-2.6.36/net/nat/hw_nat/Makefile	2014-03-28 15:00:47.542531591 +0800
@@ -1,5 +1,9 @@
 obj-$(CONFIG_RA_HW_NAT) += hw_nat.o
 hw_nat-objs := ra_nat.o foe_fdb.o util.o hwnat_ioctl.o
+ifeq ($(CONFIG_RA_HW_NAT_PPTP_L2TP),y)
+hw_nat-objs += fast_path.o
+hw_nat-objs += pptp_l2tp_fdb.o
+endif
 
 ifeq ($(CONFIG_RALINK_RT3052),y)
 hw_nat-objs += sys_rfrw.o
Index: linux-2.6.36/net/nat/hw_nat/fast_path.c
===================================================================
--- linux-2.6.36.orig/net/nat/hw_nat/fast_path.c	2014-03-28 15:00:47.514531591 +0800
+++ linux-2.6.36/net/nat/hw_nat/fast_path.c	2014-03-28 15:00:47.546531591 +0800
@@ -1,425 +1,487 @@
-#include <linux/config.h>
-#include <linux/proc_fs.h>
-#include <linux/types.h>
-#include <linux/errno.h>
-#include <linux/sched.h>
-#include <linux/kernel.h>
-#include <linux/kernel_stat.h>
 #include <linux/init.h>
-#include <linux/module.h>
-#include <linux/slab.h>
-#include <asm/uaccess.h>
 #include <linux/net.h>
-#include <linux/socket.h>
-
 #include <linux/netdevice.h>
 #include <linux/etherdevice.h>
 #include <linux/string.h>
-#include <net/ip.h>
-#include <net/protocol.h>
-#include <net/route.h>
-#include <net/sock.h>
-#include <net/arp.h>
-#include <net/raw.h>
-#include <net/checksum.h>
-#include <linux/netfilter.h>
-#include <linux/netfilter_ipv4.h>
-#include <linux/netlink.h>
-
-#include <linux/in.h>
-#include <linux/if_tunnel.h>
 #include <linux/if_ether.h>
-#include <linux/delay.h>
-
 #include <linux/skbuff.h>
-#include "fast_path.h"
-#include "pptp_l2tp_fdb.h"
+#include <linux/config.h>
+#include <linux/if_vlan.h>
+#include <linux/ppp_defs.h>
 #include <linux/tcp.h>
 #include <linux/udp.h>
+#include <net/ip.h>
+#include <net/checksum.h>
+#include <net/protocol.h>
+#include "fast_path.h"
+#include "pptp_l2tp_fdb.h"
 #include "ra_nat.h"
-#include <linux/config.h>
-#include <linux/if_vlan.h>
 #include "util.h"
 
-#define FAST_PPTP_PRINT	printk
+#if defined(CONFIG_GE_RGMII_INTERNAL_P4_AN) || defined(CONFIG_GE_RGMII_INTERNAL_P0_AN)
+char *ifname="eth3";
+#else
+char *ifname="eth0.2";
+#endif
+char *lanifname="br-lan";
 
-extern PktParseResult          PpeParseResult;
-extern uint32_t         DebugLevel;
+struct net_device *WanInf;
+struct net_device *LanInf;
 
-struct net_dev *wan_dev;
-char *ifname="eth0";
-char *pppname="ppp0";
-
-struct pptp_info {
-    struct net_device *wan_dev;
-    unsigned int tx_seqno;
-    unsigned int rx_seqno;
-    __u32 saddr;
-    __u32 daddr;
-    __u16 callID;
-    __u16 callID_udp;/*tcp udp with different ID*/
-    __u16 callID_tcp;
-    __u16 peer_callID;
-    __u16 tx_ipID;
-    __u16 ipID;
-    struct net_device *ppp0_dev;
-    struct net_device *lan_dev;
-    unsigned char mac_header[ETH_HLEN];
-    unsigned int tx_seqno_daemon;
-    unsigned int rx_seqno_daemon;
-    int ppp_hdr_len;
-    unsigned char ppp_hdr[4];
-    __u32 key;/*MT7620:add key*/
-};
-
-static struct pptp_info pptpInfo={NULL};
-extern unsigned int sync_tx_sequence;
-static struct pptp_info pptpTunnel={NULL};
+static struct hnat_l2tp l2tp_log;
+static struct hnat_l2tp l2tp_tunnel;/*for wan->lan*/
+static struct hnat_pptp pptp_log;
+static struct hnat_pptp pptp_tunnel;
+extern uint32_t sync_tx_sequence;
+extern PktParseResult   PpeParseResult;
+extern int32_t    fast_bind;
+extern uint32_t	  DebugLevel;
+extern uint16_t   wan_vid;
 
+uint8_t GetPppLength(uint8_t *data, uint8_t *protocol)
+{
+    uint8_t ppp_length = 0;
 
+    /* parse PPP length and get protocol field*/
+    if (*data == 0x0  && *(data+1)== PPP_IP){
+	ppp_length = 2;
+	*protocol = PPP_IP;
+    }
+    else if (*data == PPP_ALLSTATIONS && *(data+1) == PPP_UI){									
+	ppp_length = 2;
+	data += 2;
+	if (*data == 0x0 && *(data+1) == PPP_IP){
+	    ppp_length += 2;
+	    *protocol = PPP_IP;
+	}
+    }											
+    
+    return ppp_length ;
+}
 
-/*L2TP*/
-struct l2tp_info
-{
-    struct net_device *wan_dev;
-    struct net_device *ppp0_dev;
-    __u32 daddr;
-    __u32 saddr;
-    __u16 tid;                     /* Tunnel ID */
-    __u16 sid;                     /* Session ID */
-    __u16 source;                  /* UDP source port */
-    __u16 dest;                    /* UDP dest port */
-    unsigned char mac_header[ETH_HLEN];
-};
 
-struct l2tp_ext_hdr
+int32_t AddPptpHeader(struct sk_buff *skb, uint8_t data_offset)
 {
-    __u16 source;
-    __u16 dest;
-    __u16 len;
-    __u16 checksum;
-    __u16 type;
-    __u16 tid;
-    __u16 sid;
-    __u16 addr_control;
-    __u16 protocol;
-};
+    struct iphdr	   *iph_new = NULL;
+    struct pptp_gre_header *greh_new = NULL;	
+    struct ppp_hdr	   *ppph = NULL;
+    int32_t		   add_len = 0;
+
+    /* add L3 */
+    iph_new = (struct iphdr *)(skb->data + data_offset);    
+    memset(iph_new, 0, sizeof(struct iphdr));
+    iph_new->version	=	IPVERSION;
+    iph_new->ihl	=	5;
+    iph_new->ttl 	=	IPDEFTTL;   
+    iph_new->protocol	=	IPPROTO_GRE;
+    iph_new->saddr	=	pptp_log.saddr;
+    iph_new->daddr	=	pptp_log.daddr;
+    /* TODO: To enable checksum offload in the furure */		
+    iph_new->tot_len	=	htons(skb->len - ETH_HLEN - VLAN_LEN);		
+    skb->ip_summed	=	CHECKSUM_NONE;			
+    iph_new->id		=	htons(++pptp_log.tx_ip_id);
+    iph_new->check	=	ip_fast_csum((uint8_t *)iph_new, 5);	
+   
+    /* add gre header */
+    add_len = data_offset + sizeof(struct iphdr) + sizeof(struct pptp_gre_header) -4;
+    greh_new = (struct pptp_gre_header *)(skb->data + data_offset + sizeof(struct iphdr));
+    greh_new->flags		= PPTP_GRE_FLAG_K | PPTP_GRE_FLAG_S;
+    greh_new->ver		= PPTP_GRE_VER;
+    greh_new->protocol		= htons(PPTP_GRE_PROTO); /*ppp type = 0x880b*/
+    greh_new->payload		= htons(skb->len - add_len);    	
+    greh_new->cid		= pptp_log.call_id;			
+    greh_new->seq 		= htonl(++sync_tx_sequence);		
+    /* do not ack, -4 bytes*/
+
+    /* add PPP */
+    ppph = (struct vlan_hdr *)(skb->data + data_offset + sizeof(struct iphdr) + sizeof(struct pptp_gre_header) - 4);
+    ppph->addr_ctrl = htons(PPP_ADDRESS_CONTROL);
+    ppph->protocol = htons(PPP_IP);
+
+    return 0;
+}
 
-struct l2tp_header
+int32_t AddL2tpHeader(struct sk_buff *skb, uint8_t data_offset)
 {
-    __u16 ver;                   /* Version and friends */
-    __u16 length;                /* Optional Length */
-    __u16 tid;                   /* Tunnel ID */
-    __u16 cid;                   /* Caller ID */
-    __u16 Ns;                    /* Optional next sent */
-    __u16 Nr;                    /* Optional next received */
-};
-
-
-static struct l2tp_info l2tpInfo={NULL};
-static struct l2tp_info l2tpTunnel={NULL};/*for wan->lan*/
-extern void skb_dump(struct sk_buff* sk);
-
-static inline void bcopy(unsigned char *dst, unsigned char *src, int len)
-{	int i;
-    for (i=0; i<len; i++)
-	dst[i] = src[i];
+    struct iphdr	*iph_new = NULL;
+    struct l2tp_add_hdr	*l2tph_new = NULL;
+    struct ppp_hdr	*ppph = NULL;
+
+    /* add L3 */
+    iph_new = (struct iphdr *)(skb->data + data_offset);
+    memset(iph_new, 0, sizeof(struct iphdr));
+    iph_new->version	=	IPVERSION;
+    iph_new->ihl	=	5;
+    iph_new->ttl 	=	IPDEFTTL;
+    iph_new->protocol	=	IPPROTO_UDP;
+    iph_new->saddr	=	l2tp_log.saddr;
+    iph_new->daddr	=	l2tp_log.daddr;
+    iph_new->tot_len	=	htons(skb->len - data_offset);
+    skb->ip_summed	=	CHECKSUM_NONE;
+    iph_new->check	=	ip_fast_csum((uint8_t *)iph_new, 5);	
+
+    /* add UDP + L2TP */
+    l2tph_new = (struct l2tp_add_hdr *)(skb->data + data_offset + sizeof(struct iphdr));
+    l2tph_new->source		=	l2tp_log.source;
+    l2tph_new->dest		=	l2tp_log.dest;
+    l2tph_new->checksum		=	0;
+    l2tph_new->len		=	htons(skb->len - data_offset - sizeof(struct iphdr));/* UDP Length */
+    l2tph_new->type		=	0x0200; /* V2 */
+    l2tph_new->tid		=	l2tp_log.tid;
+    l2tph_new->sid		=	l2tp_log.sid;
+
+/* add PPP */
+    ppph = (struct vlan_hdr *)(skb->data + data_offset + sizeof(struct iphdr) + sizeof(struct l2tp_add_hdr));
+    ppph->addr_ctrl = htons(PPP_ADDRESS_CONTROL);
+    ppph->protocol  = htons(PPP_IP);
+
+    return 0;
 }
 
 
-// Packet come from WAN, and it is GRE data
-//	  delete IP+GRE+PPP header
-//
-extern int fast_bind;
-int fast_pptp_to_lan(struct sk_buff **pskb)
-{
-    struct	iphdr *iph = NULL;
-    struct	iphdr *iph_ppp0 = NULL;
-    struct	ethhdr *eth = NULL;
-    struct	pptp_gre_hdr *greh;
-    unsigned char ppp_type=0;
-    void	*ppp;
-    struct	sk_buff *skb = *pskb;
-    int	pull_offset=0;
-    struct	tcphdr *th = NULL;
-    struct	udphdr *uh = NULL;
-    int	check_stats=0;
-    unsigned int addr = 0;
 
-    iph = (struct iphdr *)(skb->data + 4);
+int32_t HnatPptpLan(struct sk_buff *skb)
+{		
+    struct	iphdr *iph_ppp0 = NULL;
+    struct	iphdr *iph	= NULL;
+#if defined (CONFIG_HNAT_V2) && defined (CONFIG_RALINK_MT7620)	    
+    struct	ethhdr *eth	= NULL;
+#endif
+    struct	pptp_gre_header *greh;					
+    struct	tcphdr *th	= NULL;
+    struct	udphdr *uh	= NULL;	
+    uint32_t	addr		= 0;
+    uint32_t    offset		= 8;	// gre 8 bytes, wothout seq and ack
+    uint32_t    ppp_length	= 0;
+    uint8_t	*ppp_format;	
+    uint8_t	ppp_protocol	= 0;
 
-    if (iph->protocol != IPPROTO_GRE || skb->len < sizeof(struct iphdr)){
+    iph = (struct iphdr *)(skb->data + VLAN_LEN);
+    if(iph->protocol != IPPROTO_GRE || skb->len < 60){
 	return 1;
     }
-    greh = (struct pptp_gre_hdr *)(skb->data + (iph->ihl*4) + 4);
+    greh = (struct pptp_gre_header *)(skb->data + (iph->ihl*4) + VLAN_LEN);
 
-    if ((greh->version&7) == PPTP_GRE_VERSION &&
-	    ntohs(greh->protocol) == PPTP_GRE_PROTOCOL) {
-	unsigned char *ppp_data;
-	int offset = sizeof(*greh) - 8;	// delete seq and ack no
-	int ppp_offset=0;
-
-	if (PPTP_GRE_IS_S(greh->flags)) {
-	    pptpInfo.rx_seqno = ntohl(greh->seq);
+    /* handle PPTP packet */
+    if ((greh->ver&7) == PPTP_GRE_VER && ntohs(greh->protocol) == PPTP_GRE_PROTO){
+	/* check optional length */
+	if (PPTP_GRE_IS_S(greh->flags)){	
+	    pptp_log.rx_seqno = ntohl(greh->seq);
 	    offset += 4;
-	}
+	}	
 
-	if (PPTP_GRE_IS_A(greh->version))
+	if (PPTP_GRE_IS_A(greh->ver))
 	    offset += 4;
 
-	ppp_data = ((char *)greh) + offset;
-	ppp_offset = 0;
-	if (greh->payload_len > 0) {
-	    // check PPP IP protocol
-	    if (*ppp_data == 0) {
-		ppp_offset = 1;
-		ppp_data++;
-	    }
-	    else if (*ppp_data == 0xff && *(ppp_data+1) == 0x03) {
-		ppp_offset = 2;
-		ppp_data += 2;
-		if (*ppp_data == 0x00) {
-		    ppp_offset++;
-		    ppp_data++;
-		}
-	    }
-	    if (*ppp_data == 0x21 || *ppp_data == 0xfd) {
-		ppp_offset++;
-		ppp_type = *ppp_data;
-	    }
-	    else
-		ppp_offset = 0;
+	ppp_format = ((char *)greh) + offset;				
+
+	if (greh->payload > 0){	
+	    ppp_length = GetPppLength(ppp_format, &ppp_protocol);
 	}
-	if (ppp_offset ==  0)
-	{
+
+	if (ppp_length ==  0){
 	    return 1;
 	}
-	offset = iph->ihl*4 + offset + ppp_offset;	// tunnel IP offset
 
-	iph_ppp0 = (struct iphdr *)(skb->data + offset + 4);
+	/*calculate remove length*/
+	offset = iph->ihl*4 + offset + ppp_length;	/* add IP offset */	
 
-	if(!fast_bind)
-	{
-	    pptpTunnel.saddr = iph_ppp0->saddr;
-	    pptpTunnel.daddr = iph_ppp0->daddr;
+	iph_ppp0 = (struct iphdr *)(skb->data + offset + VLAN_LEN);
+
+	if(!fast_bind){
+	    pptp_tunnel.saddr = iph_ppp0->saddr;
+	    pptp_tunnel.daddr = iph_ppp0->daddr;
 	}
-	//printk("PPTP SIP=%s\n", Ip2Str(pptpInfo.saddr));
-	//printk("PPTP DIP=%s\n", Ip2Str(pptpInfo.daddr));
 
-	if(iph_ppp0->protocol == IPPROTO_TCP)
-	{
-	    th = (struct tcphdr *)(skb->data + offset + 4 + 20);
+	if(iph_ppp0->protocol == IPPROTO_TCP){
+	    th = (struct tcphdr *)(skb->data + offset + VLAN_LEN + 20);
 	    addr = ((th->source << 16)|th->dest);
 	    //printk("TCP src port=%d, dst port=%d", ntohs(th->source), ntohs(th->dest));
 	}
-	else if (iph_ppp0->protocol == IPPROTO_UDP)
-	{
-	    uh = (struct udphdr *)(skb->data + offset + 4 + 20);
+	else if (iph_ppp0->protocol == IPPROTO_UDP){
+	    uh = (struct udphdr *)(skb->data + offset + VLAN_LEN + 20);
 	    addr = ((uh->source << 16)|uh->dest);
-
 	    //printk("UDP src port=%d, dst port=%d", ntohs(uh->source), ntohs(uh->dest));
 	}
-	else
-	{
-	    printk("0.1 Non TCP/UDP to lan, pass up, line %d!!\n", __LINE__);
+	else{
+	    printk("HnatPptpLan, Non TCP/UDP to lan, return\n");
 	    return 1;
 
 	}
 
-
-	// !PPP_IP  pass up
-	if (ppp_type != 0x21)
-	{
-	    return 1;
+	/* not IP packet Inside,return */
+	if (ppp_protocol != PPP_IP){						
+	    return 1;				
 	}
-	else {
-	    int rev = 0;
-	    // header removal section
+	else{
+	    int32_t rev = 0;
+	    /* header removal section */
 
-	    //skb_dump(skb);
 	    rev = is_pptp_l2tp_bind(iph_ppp0->protocol, addr);
-	    if(rev)
-	    {
-		//printk("original packet!!!\n");
-		//skb_dump(skb);
-
-		/*Kurts:memory remove from head*/
-		memcpy(skb->data + 4, skb->data - offset + 4, offset);
+	    if(rev){
+		/*memory remove from head*/    
+		memcpy(skb->data + VLAN_LEN, skb->data - offset + VLAN_LEN, offset);
 		//printk("afater memmove  GRE + PPTP header\n");
-		//redirect to PPE
+		/* redirect to PPE */
 		FOE_AI(skb) = UN_HIT;
 		FOE_MAGIC_TAG(skb) = FOE_MAGIC_PPE;
 		skb_pull(skb, offset);
 		skb_push(skb, 14);
-#if defined (CONFIG_HNAT_V2)
+#if defined (CONFIG_HNAT_V2) && defined (CONFIG_RALINK_MT7620)	    
 		/*make mac table transparent*/
 		eth = (struct ethhdr *)skb->data;
 		eth->h_source[0] = 0x01;
 #endif
-		skb->dev = wan_dev;
+		skb->dev = LanInf;
 		dev_queue_xmit(skb);
 		return 0;
 	    }
 	    else{
+		/* not in bind state*/
 		FOE_MAGIC_TAG(skb) = FOE_MAGIC_FASTPATH;
-
-		if(iph_ppp0->protocol == IPPROTO_TCP)
-		{
-		    th = (struct tcphdr *)(skb->data + offset + 4 + 20);
-
+		if(iph_ppp0->protocol == IPPROTO_TCP){
+		    th = (struct tcphdr *)(skb->data + offset + VLAN_LEN + 20);
 		    FOE_SOURCE(skb) = ntohs(th->source);
 		    FOE_DEST(skb) = ntohs(th->dest);
 		}
-		else if (iph_ppp0->protocol == IPPROTO_UDP)
-		{
-		    uh = (struct udphdr *)(skb->data + offset + 4 + 20);
-
+		else if (iph_ppp0->protocol == IPPROTO_UDP){
+		    uh = (struct udphdr *)(skb->data + offset + VLAN_LEN + 20);
 		    FOE_SOURCE(skb) = ntohs(uh->source);
 		    FOE_DEST(skb) = ntohs(uh->dest);
 		}
-		else
-		{
+		else{
 		    return 1;
-
 		}
-
 		return 1;
 	    }
 	}
-
-	//FAST_PPTP_PRINT("delete GRE + PPTP header\n");
 	LAYER3_HEADER(skb) = skb->data;
 	LAYER4_HEADER(skb) = skb->data;
-
-	FAST_PPTP_PRINT("pass up\n");
     }
+    return 1;		
+}
 
+int32_t HnatPptpWan(struct sk_buff *skb)
+{
+    struct   iphdr *iph = NULL;
+    struct   vlan_ethhdr *veth = NULL;
+    uint32_t add_len = 0;
 
+    iph = (struct iphdr *)(skb->data + VLAN_LEN);	
+    /* set tcp udp with different call ID */
+    if(iph->protocol == IPPROTO_TCP){
+	pptp_log.call_id = pptp_log.call_id_tcp;
+    } else{
+	pptp_log.call_id = pptp_log.call_id_udp;
+    }
 
+    /*  mac+ip+gre+ppp-4(ack) */
+    add_len = ETH_HLEN + VLAN_LEN + sizeof(struct iphdr) + sizeof(struct pptp_gre_header) -4; 	
+    if (skb_headroom(skb) < add_len || skb_shared(skb) ||
+	    (skb_cloned(skb) && !skb_clone_writable(skb,0))){
+		struct sk_buff *new_skb = skb_realloc_headroom(skb, add_len);
+		if (!new_skb){
+			printk("realloc headroom failed!\n");	
+			return 1;
+		}
+		kfree_skb(skb);
+		skb = new_skb;
+    }
+    /* add L2	*/					
+    memcpy(skb_push(skb, add_len), pptp_log.eth_header, ETH_HLEN);
+
+#if defined(CONFIG_GE_RGMII_INTERNAL_P4_AN) || defined(CONFIG_GE_RGMII_INTERNAL_P0_AN)
+    veth = (struct vlan_ethhdr *)(skb->data);
+    veth->h_vlan_proto = htons(ETH_P_IP);
+#else
+    /* add vid 2 */
+    veth = (struct vlan_ethhdr *)(skb->data);
+    veth->h_vlan_proto = htons(ETH_P_8021Q);
+    veth->h_vlan_TCI = htons(wan_vid);
+    veth->h_vlan_encapsulated_proto = htons(ETH_P_IP);
+#endif
 
-    return 1;
+    AddPptpHeader(skb, ETH_HLEN + VLAN_LEN);
+    skb->dev=WanInf;
+    FOE_AI(skb) = UN_HIT;
+    dev_queue_xmit(skb);
+    return 0;	
 }
 
-// Packet come from LAN and dst dev is ppp0,
-// add IP+GRE+PPTP header
-int fast_pptp_to_wan(struct sk_buff *skb)
-{
-    int	header_len;
-    struct iphdr *iph_new, iph_newone;
-    struct pptp_gre_hdr	*greh, grehone;
-    unsigned char tos;
-    unsigned short frag_off;
-    int ppp_hdr_len=0;
-    struct iphdr *iph;
-    struct net_dev *dev;
-    struct vlan_ethhdr *veth=NULL;
-    struct vlan_hdr *ppph=NULL;
 
-    iph = (struct iphdr *)(skb->data + 4);
-    /*set tcp udp with different call ID*/
-    if(iph->protocol == IPPROTO_TCP){
-	pptpInfo.callID = pptpInfo.callID_tcp;
-    }
-    else {
-	pptpInfo.callID = pptpInfo.callID_udp;
+/*L2TP*/
+int32_t HnatL2tpLan(struct sk_buff *skb)
+{		
+    struct iphdr *iph_ppp0 = NULL;
+#if defined (CONFIG_HNAT_V2) && defined (CONFIG_RALINK_MT7620)	    
+    struct ethhdr *eth = NULL;
+#endif
+    struct hnat_l2tp_parse  *l2tpremove;
+    uint8_t ppp_protocol = 0;
+    struct iphdr *iph = NULL;
+    struct tcphdr *th = NULL;
+    struct udphdr *uh = NULL;	
+    uint32_t addr = 0;
+    uint8_t *ppp_format;	
+    int32_t offset = 6;	//l2tp header from 6 
+    int32_t ppp_length = 0;
+
+    iph = (struct iphdr *)(skb->data + VLAN_LEN);
+    if (iph->protocol != IPPROTO_UDP || skb->len < 60){
+	return 1;
     }
 
-    {
-	extern int ppp_start_xmit(struct sk_buff *skb, struct net_device *dev);
-	extern void *get_ppp_vj(void *ppp);
-	extern unsigned int get_ppp_xstate(void *ppp);
-	extern void *get_ppp_xc_state(void *ppp);
-	extern struct sk_buff *get_ppp_xmit_pending(void *ppp);
-	extern void set_ppp_xmit_pending(void *ppp, struct sk_buff *skb);
-	void *ppp ;
-	/*no compression support*/
-
-	tos = iph->tos;
-	frag_off = iph->frag_off;
-
-	header_len = ETH_HLEN + sizeof(*iph_new) + sizeof(*greh); // mac-header+ip+gre+ppp-4 for gre key
-
-	if (skb_headroom(skb) < header_len || skb_cloned(skb) || skb_shared(skb)) {
-	    struct sk_buff *new_skb = skb_realloc_headroom(skb, header_len);
-	    if (!new_skb) {
-		printk("%s: skb_realloc_headroom failed!\n", __FUNCTION__);
-		return 0;
-	    }
-	    dev_kfree_skb(skb);
-	    skb = new_skb;
-	}
+    uh = (struct udphdr *)(skb->data + (iph->ihl*4) + VLAN_LEN);
+    l2tpremove = (struct hnat_l2tp_parse *)(skb->data + (iph->ihl*4) + VLAN_LEN + 8);
 
-	// build mac header
-	memcpy(skb_push(skb, header_len), pptpInfo.mac_header, ETH_HLEN);
+    if(ntohs(uh->source)!=1701) /*udp source port 1701*/
+	return 1;
+    
+    if(l2tpremove->ver & 0x4000)	
+	offset += 2;
+
+    if(l2tpremove->ver & 0x0200)
+	offset += 2;
+
+    ppp_format = ((char *)l2tpremove) + offset;				
+
+    /* parse PPP length and check inside IP protocol */
+    ppp_length = GetPppLength(ppp_format, &ppp_protocol);
+    if (ppp_length ==  0)
+	return 1;
 
-	veth = (struct vlan_ethhdr *)(skb->data);
-	veth->h_vlan_proto = htons(ETH_P_8021Q);
-	veth->h_vlan_TCI = htons(0x2);
-	veth->h_vlan_encapsulated_proto = htons(ETH_P_IP);
-
-	// build ip header
-	iph_new = &iph_newone;
-	iph_new->version	=	4;
-	iph_new->ihl		=	sizeof(struct iphdr) >> 2;
-	iph_new->frag_off	=	0x0;
-	iph_new->protocol	=	IPPROTO_GRE;
-	iph_new->tos		=	0x0;
-	iph_new->daddr	=	pptpInfo.daddr;
-	iph_new->saddr	=	pptpInfo.saddr;
-	iph_new->ttl 		=	IPDEFTTL;
-	/*TODO:To enable checksum offload*/
-
-	skb->ip_summed	=	CHECKSUM_NONE;
-	iph_new->tot_len	=	htons(skb->len - ETH_HLEN-4);
-	iph_new->id		=	htons(++pptpInfo.tx_ipID);
-	iph_new->check	=	0;
-	iph_new->check	=	ip_fast_csum((unsigned char *)iph_new, iph_new->ihl);
-	pptpInfo.ipID	=	iph_new->id; // save id to check in sync_pptp_gre_seqno()
-	memcpy(skb->data + ETH_HLEN + 4, &iph_newone, sizeof(iph_newone));
-
-	// build gre header
-	greh 			= &grehone;
-	greh->flags		= PPTP_GRE_FLAG_K | PPTP_GRE_FLAG_S;
-	//greh->version	= PPTP_GRE_VERSION | PPTP_GRE_FLAG_A;
-	greh->version	= PPTP_GRE_VERSION;
-	greh->protocol	= htons(PPTP_GRE_PROTOCOL);
-	greh->payload_len	= htons(skb->len - header_len + ppp_hdr_len);
-	greh->call_id		= pptpInfo.callID;
-	greh->seq 		= htonl(++sync_tx_sequence);
-	memcpy(skb->data+ETH_HLEN+sizeof(struct iphdr)+4, &grehone, sizeof(grehone)-4);
-	//printk("add GRE header, id=%d, gre-len=%d seq=%d!\n", iph_new->id, skb->len-header_len, ntohl(greh->seq));
-
-	ppph = (struct vlan_hdr *)(skb->data+ETH_HLEN+sizeof(struct iphdr)+sizeof(grehone));
-	ppph->h_vlan_TCI = htons(PPP_ADDRESS_CONTROL);
-	ppph->h_vlan_encapsulated_proto = htons(PPP_PROTOCOL);
+    offset = iph->ihl*4 + 8/*UDP*/ + offset + ppp_length;	// tunnel IP offset	
+    iph_ppp0 = (struct iphdr *)(skb->data + offset + VLAN_LEN );/*inner IP, 8:UDP in offset*/
 
-	skb->dev=wan_dev;
+    if(!fast_bind){
+	l2tp_tunnel.saddr = iph_ppp0->saddr;
+	l2tp_tunnel.daddr = iph_ppp0->daddr;
+    }
+    /* get source&dest port to check if binded */
+    if(iph_ppp0->protocol == IPPROTO_TCP){
+	th = (struct tcphdr *)(skb->data + offset + VLAN_LEN + 20);
+	addr = ((th->source << 16)|th->dest);
+	//printk("TCP src port=%d, dst port=%d", ntohs(th->source), ntohs(th->dest));
+    }
+    else if (iph_ppp0->protocol == IPPROTO_UDP){
+	uh = (struct udphdr *)(skb->data + offset + VLAN_LEN + 20);
+	addr = ((uh->source << 16)|uh->dest);
+    }
+    else{
+	printk("HnatL2tpLan, Non TCP/UDP to lan\n");
+	return 1;
+    }
+    /* not IP packet in PPP */
+    if(ppp_protocol != PPP_IP){						
+	return 1;				
+    }
+    else{
+	int32_t rev = 0;
+	/* header removal section */
+
+	rev = is_pptp_l2tp_bind(iph_ppp0->protocol, addr);
+	if(rev){
+	    /* memory remove from head */    
+	    memcpy(skb->data + VLAN_LEN, skb->data - offset + VLAN_LEN, offset);
+	    //printk("Bind flow,  remmove L2TP header send to PPE\n");
+	    /* redirect to PPE */
+	    FOE_AI(skb) = UN_HIT;
+	    FOE_MAGIC_TAG(skb) = FOE_MAGIC_PPE;
+	    skb_pull(skb, offset);
+	    skb_push(skb, 14);
+#if defined (CONFIG_HNAT_V2) && defined (CONFIG_RALINK_MT7620)	    
+	    /* make mac table transparent */
+	    eth = (struct ethhdr *)skb->data;
+	    eth->h_source[0] = 0x01;
+#endif
+	    skb->dev = LanInf;
+	    dev_queue_xmit(skb);
+	    return 0;
+	}
+	else{
+	    FOE_MAGIC_TAG(skb) = FOE_MAGIC_FASTPATH;
 
-	FOE_AI(skb) = UN_HIT;
-	dev_queue_xmit(skb);
+	    if(iph_ppp0->protocol == IPPROTO_TCP){
+		th = (struct tcphdr *)(skb->data + offset + VLAN_LEN + 20);
+		//printk("l2tp_to_lan: TCP src port=%d, dst port=%d\n", ntohs(th->source), ntohs(th->dest));
+		FOE_SOURCE(skb) = ntohs(th->source);
+		FOE_DEST(skb) = ntohs(th->dest);
+	    }
+	    else if (iph_ppp0->protocol == IPPROTO_UDP){
+		uh = (struct udphdr *)(skb->data + offset + VLAN_LEN + 20);
+		//printk("UDP src port=%d, dst port=%d", ntohs(uh->source), ntohs(uh->dest));
+		FOE_SOURCE(skb) = ntohs(uh->source);
+		FOE_DEST(skb) = ntohs(uh->dest);
+	    }
+	    else{
+		printk("HnatL2tpLan, return line %d!!\n", __LINE__);
+		return 1;
+
+	    }
+	    return 1;
+	}
+    }
+    LAYER3_HEADER(skb) = skb->data;
+    LAYER4_HEADER(skb) = skb->data;
+    return 1;		
+}
 
-	return 0;
+
+int32_t HnatL2tpWan(struct sk_buff *skb)
+{	
+    uint32_t		add_len = 0;
+    struct vlan_ethhdr	*veth = NULL;
+
+    add_len = ETH_HLEN + sizeof(struct iphdr) + 8 + 6 + 4;/* UDP(8)+L2TP(6)+PPP(4) */
+    if (skb_headroom(skb) < add_len || skb_shared(skb) ||
+	    (skb_cloned(skb) && !skb_clone_writable(skb,0))){
+		struct sk_buff *new_skb = skb_realloc_headroom(skb, add_len);
+		if (!new_skb){
+			printk("realloc headroom failed!\n");	
+			return 1;
+		}
+		kfree_skb(skb);
+		skb = new_skb;
     }
+    /* add L2 */
+    memcpy(skb_push(skb, add_len), l2tp_log.eth_header, ETH_HLEN);
+#if defined(CONFIG_GE_RGMII_INTERNAL_P4_AN) || defined(CONFIG_GE_RGMII_INTERNAL_P0_AN)
+    veth = (struct vlan_ethhdr *)(skb->data);
+    veth->h_vlan_proto = htons(ETH_P_IP);
+#else
+   /* add wan vid*/
+    veth = (struct vlan_ethhdr *)(skb->data);
+    veth->h_vlan_proto = htons(ETH_P_8021Q);
+    veth->h_vlan_TCI = htons(wan_vid);
+    veth->h_vlan_encapsulated_proto = htons(ETH_P_IP);
+#endif
+   
+    AddL2tpHeader(skb, ETH_HLEN + VLAN_LEN);
+    skb->dev =	WanInf;
+    FOE_AI(skb) = UN_HIT;
 
+    dev_queue_xmit(skb);	
     return 0;
 }
-int  fast_pptp_init(void)
-{
-    if(wan_dev=ra_dev_get_by_name(ifname)){
-	//printk("wan_dev name is %s!\n", wan_dev->name);
-    }
 
+
+
+
+int32_t  HnatPptpL2tpInit(void)
+{
+    WanInf = ra_dev_get_by_name(ifname);
+    LanInf = ra_dev_get_by_name(lanifname);
+    //printk("WanInf name is %s!\n", WanInf->name);
     return 0;
 }
 
-int  fast_pptp_clean(void)
+int32_t  HnatPptpL2tpClean(void)
 {
-    if (wan_dev != NULL) {
-	dev_put(wan_dev);
+    if(WanInf != NULL){
+	dev_put(WanInf);
     }
-
-    if (pptpInfo.ppp0_dev != NULL) {
-	dev_put(pptpInfo.ppp0_dev);
+    if(LanInf != NULL){
+	dev_put(LanInf);
     }
     return 0;
 }
@@ -428,23 +490,18 @@
 
 int32_t SendL2TPHashPkt(struct sk_buff *pskb)
 {
-    struct net_dev *dev;
     struct sk_buff *skb = NULL;
     struct iphdr *iph = NULL;
     struct iphdr *iph_new = NULL;
     struct tcphdr *th = NULL;
     struct udphdr *uh = NULL;
 
-    unsigned char pkt[]={
-	//0xff, 0xff, 0xff, 0xff, 0xff, 0xff, // dest bcast mac
+    uint8_t pkt[]={
 	0x00, 0x30, 0xda, 0x01, 0x02, 0x0f, // dest macA
-	//0x00, 0x30, 0xdb, 0x02, 0x02, 0x01, // dest macB
 	0x00, 0x88, 0x99, 0x00, 0xaa, 0xbb, // src mac
 	0x81, 0x00, // vlan tag
-	//0x00, 0x01, // pri=0, vlan=1
 	0x01, 0x23, // pri=0, vlan=1
 	0x08, 0x00, // eth type=ip
-	//0x45, 0x00, 0x00, 0x30, 0x12, 0x34, 0x40, 0x00, 0xff, 0x11,//UDP
 	0x45, 0x00, 0x00, 0x30, 0x12, 0x34, 0x40, 0x00, 0xff, 0x06, //TCP
 	0x40, 0x74, 0x0a, 0x0a, 0x1e, 0x0a, 0x0a, 0x0a, 0x1e, 0x0b,
 	0x00, 0x1e, 0x00, 0x28, 0x00, 0x1c, 0x81, 0x06, 0x00, 0x00,
@@ -455,20 +512,16 @@
     if( skb == NULL){
 	return 1;
     }
-    if (DebugLevel >= 1) {
+    if(DebugLevel >= 1){
 	printk("Ori source port = %d\n",FOE_SOURCE(pskb));
     }
-    //printk("Ori dest port = %d\n",FOE_DEST(pskb));
-    /*TODO:need to consider HW vlan*/
-    iph = (struct iphdr *)(pskb->data+14 + 4);
-
-    // skb_dump(pskb);
-
-    if(1)
-    {
-	skb->dev=wan_dev;
-	//skb->dev = DstPort[DP_GMAC];  //we use GMAC1 to send the packet to PPE
-	//redirect to PPE
+    /* TODO:consider HW vlan in the future */
+    /* slow path information */
+    iph = (struct iphdr *)(pskb->data+14 + VLAN_LEN);
+
+    if(1){
+	skb->dev=LanInf;
+	/* we use GMAC1 to send the packet to PPE */
 	FOE_AI(skb) = UN_HIT;
 	FOE_MAGIC_TAG(skb) = FOE_MAGIC_PPE;
 
@@ -478,34 +531,32 @@
 
 	iph_new = (struct iphdr *)(skb->data+14 + 4);
 
-	/*from wan -> lan*/
-	iph_new->saddr = l2tpTunnel.saddr;
-	iph_new->daddr = l2tpTunnel.daddr;
+	/* from wan -> lan */
+	iph_new->saddr = l2tp_tunnel.saddr;
+	iph_new->daddr = l2tp_tunnel.daddr;
 
-	if(iph->protocol == IPPROTO_TCP)
-	{
+	if(iph->protocol == IPPROTO_TCP){
 	    skb_put(skb, (14+4+sizeof(struct iphdr)+sizeof(struct tcphdr)));
-	    memcpy(skb->data+14+4+40, pskb->data, (14+4+sizeof(struct iphdr)+sizeof(struct tcphdr)));
+	    memcpy(skb->data+14+4+40, pskb->data, (14+VLAN_LEN+sizeof(struct iphdr)+sizeof(struct tcphdr)));
 
 	    th = (struct tcphdr *)(skb->data +20 +14 + 4);
 	    th->source = htons(FOE_SOURCE(pskb));
 	    th->dest = htons(FOE_DEST(pskb));
-	    //printk("original pkt is TCP \n");
-
-	    if (DebugLevel >= 1) {
+	    if(DebugLevel >= 1){
 		printk("send pingpong TCP  pkt:\n");
 	    }
 	}
-	else if(iph->protocol == IPPROTO_UDP)
-	{
+	else if(iph->protocol == IPPROTO_UDP){
 	    uh = (struct udphdr *)(skb->data +20 +14 + 4);
 	    uh->source = htons(FOE_SOURCE(pskb));
 	    uh->dest = htons(FOE_DEST(pskb));
 
-	    printk("send pingpong UDP pkt\n");
+	    if (DebugLevel >= 1){
+		printk("send pingpong UDP pkt\n");
+	    }
 	}
-
-	if (DebugLevel >= 1) {
+	
+	if (DebugLevel >= 1){
 	    printk("send L2TP Hash pkt(len=%d) dport=%d to %s\n", skb->len,FOE_DEST(pskb), skb->dev->name);
 	}
 	dev_queue_xmit(skb);
@@ -513,30 +564,24 @@
 	printk("interface %s not found\n",ifname);
 	return 1;
     }
-
     return 0;
 }
 
 
 int32_t SendHashPkt(struct sk_buff *pskb)
 {
-    struct net_dev *dev;
     struct sk_buff *skb = NULL;
     struct iphdr *iph = NULL;
     struct iphdr *iph_new = NULL;
     struct tcphdr *th = NULL;
     struct udphdr *uh = NULL;
 
-    unsigned char pkt[]={
-	//0xff, 0xff, 0xff, 0xff, 0xff, 0xff, // dest bcast mac
-	0x00, 0x30, 0xda, 0x01, 0x02, 0x0f, // dest macA
-	//0x00, 0x30, 0xdb, 0x02, 0x02, 0x01, // dest macB
-	0x00, 0x88, 0x99, 0x00, 0xaa, 0xbb, // src mac
-	0x81, 0x00, // vlan tag
-	//0x00, 0x01, // pri=0, vlan=1
-	0x01, 0x23, // pri=0, vlan=0x123
-	0x08, 0x00, // eth type=ip
-	//0x45, 0x00, 0x00, 0x30, 0x12, 0x34, 0x40, 0x00, 0xff, 0x11,//UDP
+    uint8_t pkt[]={
+	0x00, 0x30, 0xda, 0x01, 0x02, 0x0f,	// dest macA
+	0x00, 0x88, 0x99, 0x00, 0xaa, 0xbb,	// src mac
+	0x81, 0x00,				// vlan tag
+	0x01, 0x23,				// pri=0, vlan=0x123
+	0x08, 0x00,				// eth type=ip
 	0x45, 0x00, 0x00, 0x30, 0x12, 0x34, 0x40, 0x00, 0xff, 0x06, //TCP
 	0x40, 0x74, 0x0a, 0x0a, 0x1e, 0x0a, 0x0a, 0x0a, 0x1e, 0x0b,
 	0x00, 0x1e, 0x00, 0x28, 0x00, 0x1c, 0x81, 0x06, 0x00, 0x00,
@@ -547,18 +592,16 @@
     if( skb == NULL){
 	return 1;
     }
-    if (DebugLevel >= 1) {
+    if(DebugLevel >= 1){
 	printk("Ori source port = %d\n",FOE_SOURCE(pskb));
     }
     //printk("Ori dest port = %d\n",FOE_DEST(pskb));
     /*no  HW vlan*/
     iph = (struct iphdr *)(pskb->data+14 + 4);
 
-    if(1)
-    {
-	skb->dev=wan_dev;
-	//skb->dev = DstPort[DP_GMAC];  //we use GMAC1 to send the packet to PPE
-
+    if(1){
+	skb->dev=LanInf;
+	//use GMAC1 to send the packet to PPE
 	//redirect to PPE
 	FOE_AI(skb) = UN_HIT;
 	FOE_MAGIC_TAG(skb) = FOE_MAGIC_PPE;
@@ -569,12 +612,11 @@
 
 	iph_new = (struct iphdr *)(skb->data+14 + 4);
 
-	/*from wan -> lan*/
-	iph_new->saddr = pptpTunnel.saddr;
-	iph_new->daddr = pptpTunnel.daddr;
+	/* from wan -> lan */
+	iph_new->saddr = pptp_tunnel.saddr;
+	iph_new->daddr = pptp_tunnel.daddr;
 
-	if(iph->protocol == IPPROTO_TCP)
-	{
+	if(iph->protocol == IPPROTO_TCP){
 	    skb_put(skb, (14+4+sizeof(struct iphdr)+sizeof(struct tcphdr)));
 	    memcpy(skb->data+14+4+40, pskb->data, (14+4+sizeof(struct iphdr)+sizeof(struct tcphdr)));
 
@@ -584,12 +626,11 @@
 	    //printk("original pkt is TCP \n");
 	    //printk("original pkt:\n");
 
-	    if (DebugLevel >= 1) {
+	    if (DebugLevel >= 1){
 		printk("send pingpong TCP  pkt:\n");
 	    }
 	}
-	else if(iph->protocol == IPPROTO_UDP)
-	{
+	else if(iph->protocol == IPPROTO_UDP){
 	    uh = (struct udphdr *)(skb->data +20 +14 + 4);
 	    uh->source = htons(FOE_SOURCE(pskb));
 		uh->dest = htons(FOE_DEST(pskb));
@@ -597,14 +638,14 @@
 		printk("send pingpong UDP pkt\n");
 	}
 
-	if (DebugLevel >= 1) {
+	if (DebugLevel >= 1){
 		printk("send Hash pkt(len=%d) dport=%d to %s\n", skb->len,FOE_DEST(pskb), skb->dev->name);
 	}
 
 	dev_queue_xmit(skb);
     }else{
 	printk("interface %s not found\n",ifname);
-        //kfree_skb(skb);
+        kfree_skb(skb);
 	return 1;
     }
 
@@ -617,12 +658,11 @@
 	struct vlan_hdr *vh = NULL;
 	struct ethhdr *eth = NULL;
 	struct iphdr *iph = NULL;
-	struct ipv6hdr *ip6h = NULL;
 	struct tcphdr *th = NULL;
 	struct udphdr *uh = NULL;
 
 	struct iphdr *iph_ori = NULL;
-	int offset = 0;
+	int32_t offset = 0;
 #ifdef CONFIG_RAETH_HW_VLAN_TX
 	struct vlan_hdr pseudo_vhdr;
 #endif
@@ -635,10 +675,10 @@
 	}
 
 	iph_ori = (struct iphdr *)(skb->data + 4);
-	if (iph_ori->protocol == IPPROTO_TCP) {
+	if(iph_ori->protocol == IPPROTO_TCP){
 	    offset = VLAN_HLEN + (iph_ori->ihl * 4) + sizeof(struct tcphdr);
 	}
-	else if (iph_ori->protocol == IPPROTO_TCP) {
+	else if(iph_ori->protocol == IPPROTO_TCP){
 	    offset = VLAN_HLEN + (iph_ori->ihl * 4) + sizeof(struct udphdr);
 	}
 	else{
@@ -646,7 +686,6 @@
 	    return 1;
 	}
 
-	//skb_dump(skb);
 
 	eth = (struct ethhdr *)(skb->data + offset);
 	memcpy(PpeParseResult.dmac, eth->h_dest, ETH_ALEN);
@@ -655,18 +694,17 @@
 
 	// we cannot speed up multicase packets because both wire and wireless PCs might join same multicast group.
 #if defined(CONFIG_RALINK_MT7620)
-	if(is_multicast_ether_addr(&eth->h_dest[0])) {
+	if(is_multicast_ether_addr(&eth->h_dest[0])){
 		PpeParseResult.is_mcast = 1;
-	}else {
+	}else{
 		PpeParseResult.is_mcast = 0;
 	}
 #else
-	if(is_multicast_ether_addr(&eth->h_dest[0])) {
+	if(is_multicast_ether_addr(&eth->h_dest[0])){
 		return 1;
 	}
 #endif
 	if (is8021Q(PpeParseResult.eth_type) || isSpecialTag(PpeParseResult.eth_type) || isHwVlanTx(skb)) {
-		//printk("PpeParseResult!!!!!!!!!!!!!\n");
 #ifdef CONFIG_RAETH_HW_VLAN_TX
 		PpeParseResult.vlan1_gap = 0;
 		PpeParseResult.vlan_layer++;
@@ -681,6 +719,12 @@
 		PpeParseResult.vlan1 = vh->h_vlan_TCI;
 		PpeParseResult.eth_type = vh->h_vlan_encapsulated_proto;
 	}
+	
+	//printk("offset is %d!!!!!!!!!!!!!\n",offset);
+	//printk("ETH_HLEN is %d!!!!!!!!!!!!!\n",ETH_HLEN);
+	//printk("PpeParseResult.vlan1_gap is %d!!!!!!!!!!!!!\n",PpeParseResult.vlan1_gap);
+	//printk("PpeParseResult.vlan2_gap is %d!!!!!!!!!!!!!\n",PpeParseResult.vlan2_gap);
+	    
 	/* set layer2 start addr */
 	LAYER2_HEADER(skb) = skb->data + offset;
 
@@ -690,36 +734,36 @@
 	     PpeParseResult.vlan2_gap + PpeParseResult.pppoe_gap);
 
 	/* set layer4 start addr */
-	if ((PpeParseResult.eth_type == htons(ETH_P_IP))) {
+	if((PpeParseResult.eth_type == htons(ETH_P_IP))){
 		iph = (struct iphdr *)LAYER3_HEADER(skb);
 
 		//prepare layer3/layer4 info
 		memcpy(&PpeParseResult.iph, iph, sizeof(struct iphdr));
-		if (iph->protocol == IPPROTO_TCP) {
+		if(iph->protocol == IPPROTO_TCP){
 			LAYER4_HEADER(skb) = ((uint8_t *) iph + (iph->ihl * 4));
 			th = (struct tcphdr *)LAYER4_HEADER(skb);
 			memcpy(&PpeParseResult.th, th, sizeof(struct tcphdr));
 			PpeParseResult.pkt_type = IPV4_HNAPT;
 
-			if(iph->frag_off & htons(IP_MF|IP_OFFSET)) {
+			if(iph->frag_off & htons(IP_MF|IP_OFFSET)){
 				return 1;
 			}
-		} else if (iph->protocol == IPPROTO_UDP) {
+		}else if(iph->protocol == IPPROTO_UDP){
 			LAYER4_HEADER(skb) = ((uint8_t *) iph + iph->ihl * 4);
 			uh = (struct udphdr *)LAYER4_HEADER(skb);
 			memcpy(&PpeParseResult.uh, uh, sizeof(struct udphdr));
 			PpeParseResult.pkt_type = IPV4_HNAPT;
-
-			if(iph->frag_off & htons(IP_MF|IP_OFFSET)) {
+			
+			if(iph->frag_off & htons(IP_MF|IP_OFFSET)){
 				return 1;
 			}
 		}
 #if defined (CONFIG_HNAT_V2)
-		else if (iph->protocol == IPPROTO_GRE) {
+		else if(iph->protocol == IPPROTO_GRE){
 			/* do nothing */
 		}
 #endif
-		else {
+		else{
 			/* Packet format is not supported */
 			return 1;
 		}
@@ -780,7 +824,7 @@
 			printk("DIP=%s\n",
 			       Ip2Str(ntohl(PpeParseResult.iph.daddr)));
 			printk("TOS=%x\n", ntohs(PpeParseResult.iph.tos));
-
+			
 			if (PpeParseResult.iph.protocol == IPPROTO_TCP) {
 			    printk("TCP SPORT=%d\n", ntohs(PpeParseResult.th.source));
 			    printk("TCP DPORT=%d\n", ntohs(PpeParseResult.th.dest));
@@ -791,756 +835,447 @@
 		}
 	}
 
-	return 0;/*OK*/
+	return 0;/* OK */
 }
 
 
 
 int32_t PptpToWanParseLayerInfo(struct sk_buff * skb)
 {
-	struct vlan_hdr *vh = NULL;
-	struct ethhdr *eth = NULL;
-	struct iphdr *iph = NULL;
-	struct iphdr *iph_ppp0 = NULL;
-	struct ipv6hdr *ip6h = NULL;
-	struct tcphdr *th = NULL;
-	struct udphdr *uh = NULL;
+    struct vlan_hdr *vh = NULL;
+    struct ethhdr *eth = NULL;
+    struct iphdr *iph = NULL;
+    struct iphdr *iph_ppp0 = NULL;
+    struct tcphdr *th = NULL;
+    struct udphdr *uh = NULL;
 
-	struct pptp_gre_hdr *greh = NULL;
-	unsigned char *ppp_data = NULL;
-	unsigned char ppp_type=0;
-	int offset = sizeof(*greh) - 8; // delete seq and ack no
-	int ppp_offset=0;
+    struct		pptp_gre_header *greh = NULL;			
+    uint8_t	*ppp_format = NULL;	
+    int32_t		offset = sizeof(*greh) - 8; // delete seq and ack no
+    int32_t		ppp_length = 0;
 #ifdef CONFIG_RAETH_HW_VLAN_TX
-	struct vlan_hdr pseudo_vhdr;
+    struct vlan_hdr pseudo_vhdr;
 #endif
-	memset(&PpeParseResult, 0, sizeof(PpeParseResult));
-
-	eth = (struct ethhdr *)(skb->data);
-	iph_ppp0 = (struct iphdr *)(skb->data + 14 + 4);
+    memset(&PpeParseResult, 0, sizeof(PpeParseResult));
 
-	memcpy(PpeParseResult.smac, eth->h_dest, ETH_ALEN);
-	memcpy(PpeParseResult.dmac, eth->h_source, ETH_ALEN);
-	PpeParseResult.smac[0] = 0x01;
-
-	greh = (struct pptp_gre_hdr *)(skb->data + 14 + (iph_ppp0->ihl*4) + 4);
-
-/*log pptp info*/
-    pptpInfo.callID = greh->call_id;
-    pptpInfo.saddr = iph_ppp0->saddr;
-    pptpInfo.daddr = iph_ppp0->daddr;
-    memcpy(pptpInfo.mac_header, eth->h_dest, ETH_ALEN);
-    memcpy(&pptpInfo.mac_header[6], eth->h_source, ETH_ALEN);
+    eth = (struct ethhdr *)(skb->data);
+    iph_ppp0 = (struct iphdr *)(skb->data + 14 + 4);
 
-    if (DebugLevel >= 1) {
-	printk("greh->flags is 0x%1x\n", greh->flags);
-	printk("greh->versions is 0x%1x\n", greh->version);
+    memcpy(PpeParseResult.smac, eth->h_dest, ETH_ALEN);
+    memcpy(PpeParseResult.dmac, eth->h_source, ETH_ALEN);
+    PpeParseResult.smac[0] = 0x01;
+
+    greh = (struct pptp_gre_header *)(skb->data + 14 + (iph_ppp0->ihl*4) + 4);
+
+    /*log pptp info*/	
+    pptp_log.call_id = greh->cid;
+    pptp_log.saddr = iph_ppp0->saddr;
+    pptp_log.daddr = iph_ppp0->daddr;
+    memcpy(pptp_log.eth_header, eth->h_dest, ETH_ALEN);
+    memcpy(&pptp_log.eth_header[6], eth->h_source, ETH_ALEN);
+
+    if (DebugLevel >= 1){
+	printk("greh flags is 0x%1x\n", greh->flags);
+	printk("greh version is 0x%1x\n", greh->ver);
     }
-	PpeParseResult.eth_type = eth->h_proto;
-
-		if (PPTP_GRE_IS_S(greh->flags))
-		{
-			if (DebugLevel >= 1) {
-				printk("greh->seq is %d\n", ntohl(greh->seq));
-				printk("log pptpInfo.tx_seqno!!!!!!!!!!\n");
-			}
-			pptpInfo.tx_seqno = ntohl(greh->seq);
-			if (DebugLevel >= 1) {
-				printk("log pptpInfo. IP ID!!!!!!!!!!\n");
-			}
-			pptpInfo.tx_ipID = ntohs(iph_ppp0->id);
-			offset += 4;
-		}
-
-		if (PPTP_GRE_IS_A(greh->version))
-		{
-			if (DebugLevel >= 1) {
-				printk("log pptpInfo.rx_seqno ACK!!!!!!!!!!\n");
-			}
-			pptpInfo.rx_seqno =  ntohl(greh->ack);
-			offset += 4;
-		}
-		ppp_data = ((char *)greh) + offset;
-
-		ppp_offset = 0;
-		if (greh->payload_len > 0) {
-			// check PPP IP protocol
-			if (*ppp_data == 0) {
-				ppp_offset = 1;
-				ppp_data++;
-			}
-			else if (*ppp_data == 0xff && *(ppp_data+1) == 0x03) {
-				ppp_offset = 2;
-				ppp_data += 2;
-				if (*ppp_data == 0) {
-					ppp_offset++;
-					ppp_data++;
-				}
-			}
-			if (*ppp_data == 0x21 || *ppp_data == 0xfd) {
-				ppp_offset++;
-				ppp_type = *ppp_data;
-			}
-			else
-				ppp_offset = 0;
-		}
-
-	if (ppp_offset ==  0)
-			return 1;
-
-		offset = iph_ppp0->ihl*4 + offset + ppp_offset;	// tunnel IP offset
-		//offset = iph->ihl*4 + offset + ppp_offset + 4;	// tunnel IP offset + vlan
+    PpeParseResult.eth_type = eth->h_proto;
 
+    if (PPTP_GRE_IS_S(greh->flags)){	
 	if (DebugLevel >= 1) {
-		printk("pptp offset is 0x%d\n", offset);
+	    printk("greh->seq is %d\n", ntohl(greh->seq));    
+	    printk("log pptp_log.tx_seqno!!!!!!!!!!\n");
 	}
-
-	//skb_dump(skb);
-	if (is8021Q(PpeParseResult.eth_type) || isSpecialTag(PpeParseResult.eth_type) || isHwVlanTx(skb)) {
-
-#ifdef CONFIG_RAETH_HW_VLAN_TX
-		PpeParseResult.vlan1_gap = 0;
-		PpeParseResult.vlan_layer++;
-		pseudo_vhdr.h_vlan_TCI = htons(vlan_tx_tag_get(skb));
-		pseudo_vhdr.h_vlan_encapsulated_proto = eth->h_proto;
-		vh = (struct vlan_hdr *)&pseudo_vhdr;
-#else
-		PpeParseResult.vlan1_gap = VLAN_HLEN;
-		PpeParseResult.vlan_layer++;
-		vh = (struct vlan_hdr *)(skb->data + ETH_HLEN);
-#endif
-		PpeParseResult.vlan1 = vh->h_vlan_TCI;
-
-		PpeParseResult.eth_type = vh->h_vlan_encapsulated_proto;
-	}
-
-	/* set layer2 start addr, original L2 MAC */
-	LAYER2_HEADER(skb) = skb->data;
-
-	/* set layer3 start addr, inner IP */
-	LAYER3_HEADER(skb) =
-	    (skb->data + offset +ETH_HLEN + PpeParseResult.vlan1_gap +
-	     PpeParseResult.vlan2_gap);
-
+	pptp_log.tx_seqno = ntohl(greh->seq);						
 	if (DebugLevel >= 1) {
-		printk("LAN -> WAN set layer4 start addr\n");
+	    printk("log pptp_log. IP ID!!!!!!!!!!\n");
 	}
-	/* set layer4 start addr */
-	if ((PpeParseResult.eth_type == htons(ETH_P_IP))) {
-		iph = (struct iphdr *)LAYER3_HEADER(skb);
-
-		if(iph->protocol == IPPROTO_TCP)
-		{
-			//th = (struct tcphdr *)((uint8_t *) iph + (iph->ihl * 4));
-			th = (struct tcphdr *)((uint8_t *) iph + 20);
-			pptpInfo.callID_tcp = greh->call_id;
-			//printk("LAN -> WAN TCP src port=%d, dst port=%d \n", ntohs(th->source), ntohs(th->dest));
-			//printk("LAN -> WAN pptpInfo.callID_tcp =%4x\n", pptpInfo.callID_tcp);
-		}
-		else if (iph->protocol == IPPROTO_UDP)
-		{
-			uh = (struct udphdr *)((uint8_t *)iph + 20);
-			pptpInfo.callID_udp = greh->call_id;
-			//printk("UDP src port=%d, dst port=%d", ntohs(uh->source), ntohs(uh->dest));
-		}
-
-		//prepare layer3/layer4 info
-		memcpy(&PpeParseResult.iph, iph, sizeof(struct iphdr));
-		if (iph->protocol == IPPROTO_TCP) {
-			LAYER4_HEADER(skb) = ((uint8_t *) iph + (iph->ihl * 4));
-			th = (struct tcphdr *)LAYER4_HEADER(skb);
-			memcpy(&PpeParseResult.th, th, sizeof(struct tcphdr));
-			PpeParseResult.pkt_type = IPV4_HNAPT;
-			if (DebugLevel >= 1) {
-				printk("LAN -> WAN TCP src port=%d, dst port=%d \n", ntohs(th->source), ntohs(th->dest));
-			}
-			if(iph->frag_off & htons(IP_MF|IP_OFFSET)) {
-			        printk("iph->frag_off  return\n");
-				return 1;
-			}
-		} else if (iph->protocol == IPPROTO_UDP) {
-			LAYER4_HEADER(skb) = ((uint8_t *) iph + iph->ihl * 4);
-			uh = (struct udphdr *)LAYER4_HEADER(skb);
-			memcpy(&PpeParseResult.uh, uh, sizeof(struct udphdr));
-			PpeParseResult.pkt_type = IPV4_HNAPT;
-
-			if(iph->frag_off & htons(IP_MF|IP_OFFSET)) {
-				return 1;
-			}
-		}
-#if defined (CONFIG_HNAT_V2)
-		else if (iph->protocol == IPPROTO_GRE) {
-			/* do nothing */
-		}
-#endif
-		else {
-			/* Packet format is not supported */
-			return 1;
-		}
+	pptp_log.tx_ip_id = ntohs(iph_ppp0->id);
+	offset += 4;
+    }	
+
+    if (PPTP_GRE_IS_A(greh->ver)){
+	if (DebugLevel >= 1){
+	    printk("log pptp_log.rx_seqno ACK!!!!!!!!!!\n");
+	}
+	pptp_log.rx_seqno =  ntohl(greh->ack);
+	offset += 4;
+    }			
+    ppp_format = ((char *)greh) + offset;				
+
+    if (greh->payload > 0){	
+	uint8_t    ppp_protocol	= 0;
+	/* parse PPP length */
+	ppp_length = GetPppLength(ppp_format, &ppp_protocol);
+    }	
 
-	} else {
-		return 1;
-	}
-
-	if (DebugLevel >= 6) {
-		printk("--------------\n");
-		printk("DMAC:%02X:%02X:%02X:%02X:%02X:%02X\n",
-		       PpeParseResult.dmac[0], PpeParseResult.dmac[1],
-		       PpeParseResult.dmac[2], PpeParseResult.dmac[3],
-		       PpeParseResult.dmac[4], PpeParseResult.dmac[5]);
-		printk("SMAC:%02X:%02X:%02X:%02X:%02X:%02X\n",
-		       PpeParseResult.smac[0], PpeParseResult.smac[1],
-		       PpeParseResult.smac[2], PpeParseResult.smac[3],
-		       PpeParseResult.smac[4], PpeParseResult.smac[5]);
-		printk("Eth_Type=%x\n", PpeParseResult.eth_type);
-		if (PpeParseResult.vlan1_gap > 0) {
-			printk("VLAN1 ID=%x\n", ntohs(PpeParseResult.vlan1));
-		}
+    if (ppp_length ==  0) 
+	return 1;
+    /* set IP offset*/
+    offset = iph_ppp0->ihl*4 + offset + ppp_length;	
+    //offset = iph->ihl*4 + offset + ppp_length + 4;	/* + vlan */	
 
-		if (PpeParseResult.vlan2_gap > 0) {
-			printk("VLAN2 ID=%x\n", ntohs(PpeParseResult.vlan2));
-		}
+    if (DebugLevel >= 1){
+	printk("pptp offset is 0x%d\n", offset);
+    }
 
-		if (PpeParseResult.pppoe_gap > 0) {
-			printk("PPPOE Session ID=%x\n",
-			       PpeParseResult.pppoe_sid);
-			printk("PPP Tag=%x\n", ntohs(PpeParseResult.ppp_tag));
-		}
-#if defined (CONFIG_HNAT_V2)
-		printk("PKT_TYPE=%s\n",
-		       PpeParseResult.pkt_type ==
-		       0 ? "IPV4_HNAT" : PpeParseResult.pkt_type ==
-		       1 ? "IPV4_HNAPT" : PpeParseResult.pkt_type ==
-		       3 ? "IPV4_DSLITE" : PpeParseResult.pkt_type ==
-		       4 ? "IPV6_ROUTE" : PpeParseResult.pkt_type ==
-		       5 ? "IPV6_6RD" : "Unknown");
+    if (is8021Q(PpeParseResult.eth_type) || isSpecialTag(PpeParseResult.eth_type) || isHwVlanTx(skb)) 
+    {
+#ifdef CONFIG_RAETH_HW_VLAN_TX
+	PpeParseResult.vlan1_gap = 0;
+	PpeParseResult.vlan_layer++;
+	pseudo_vhdr.h_vlan_TCI = htons(vlan_tx_tag_get(skb));
+	pseudo_vhdr.h_vlan_encapsulated_proto = eth->h_proto;
+	vh = (struct vlan_hdr *)&pseudo_vhdr;
 #else
-		printk("PKT_TYPE=%s\n",
-		       PpeParseResult.pkt_type ==
-		       0 ? "IPV4_HNAPT" : PpeParseResult.pkt_type ==
-		       1 ? "IPV4_HNAT" : PpeParseResult.pkt_type ==
-		       2 ? "IPV6_ROUTE" : "Unknown");
+	PpeParseResult.vlan1_gap = VLAN_HLEN;
+	PpeParseResult.vlan_layer++;
+	vh = (struct vlan_hdr *)(skb->data + ETH_HLEN);
 #endif
+	PpeParseResult.vlan1 = vh->h_vlan_TCI;
 
-		if (PpeParseResult.pkt_type == IPV4_HNAT) {
-			printk("SIP=%s\n",
-			       Ip2Str(ntohl(PpeParseResult.iph.saddr)));
-			printk("DIP=%s\n",
-			       Ip2Str(ntohl(PpeParseResult.iph.daddr)));
-			printk("TOS=%x\n", ntohs(PpeParseResult.iph.tos));
-		} else if (PpeParseResult.pkt_type == IPV4_HNAPT) {
-			printk("SIP=%s\n",
-			       Ip2Str(ntohl(PpeParseResult.iph.saddr)));
-			printk("DIP=%s\n",
-			       Ip2Str(ntohl(PpeParseResult.iph.daddr)));
-			printk("TOS=%x\n", ntohs(PpeParseResult.iph.tos));
-
-			if (PpeParseResult.iph.protocol == IPPROTO_TCP) {
-			    printk("TCP SPORT=%d\n", ntohs(PpeParseResult.th.source));
-			    printk("TCP DPORT=%d\n", ntohs(PpeParseResult.th.dest));
-			}else if(PpeParseResult.iph.protocol == IPPROTO_UDP) {
-			    printk("UDP SPORT=%d\n", ntohs(PpeParseResult.uh.source));
-			    printk("UDP DPORT=%d\n", ntohs(PpeParseResult.uh.dest));
-			}
-		}
-	}
-
-	return 0;/*0 means OK here*/
-}
-
-
-/*L2TP*/
-
-int fast_l2tp_to_lan(struct sk_buff **pskb)
-{
-	struct iphdr *iph_ppp0 = NULL;
-	struct ethhdr *eth = NULL;
-	struct l2tp_header  *l2tph;
-	unsigned char ppp_type=0;
-	void *ppp;
-	struct sk_buff *skb = *pskb;
-	struct iphdr *iph = NULL;
-	int pull_offset=0;
-        struct tcphdr *th = NULL;
-        struct udphdr *uh = NULL;
-	int check_stats=0;
-	unsigned int addr = 0;
-
-	iph = (struct iphdr *)(skb->data + 4);
+	PpeParseResult.eth_type = vh->h_vlan_encapsulated_proto;
+    }
 
-	if (iph->protocol != IPPROTO_UDP || skb->len < sizeof(struct iphdr)){
-    	    return 1;
-	}
+    /* set layer2 start addr, original L2 MAC */
+    LAYER2_HEADER(skb) = skb->data;
 
-	uh = (struct udp_hdr *)(skb->data + (iph->ihl*4) + 4);
-	l2tph = (struct l2tp_header *)(skb->data + (iph->ihl*4) + 4 + 8);
+    /* set layer3 start addr, inner IP */
+    LAYER3_HEADER(skb) =
+	(skb->data + offset +ETH_HLEN + PpeParseResult.vlan1_gap +
+	 PpeParseResult.vlan2_gap);
 
-	if(ntohs(uh->source)!=1701) /*port:1701*/
-	{
-	    return 1;
+    if (DebugLevel >= 1) {
+	printk("LAN -> WAN set layer4 start addr\n");
+    }
+    /* set layer4 start addr */
+    if ((PpeParseResult.eth_type == htons(ETH_P_IP))){
+	iph = (struct iphdr *)LAYER3_HEADER(skb);
+
+	if(iph->protocol == IPPROTO_TCP){
+	    th = (struct tcphdr *)((uint8_t *) iph + 20);
+	    pptp_log.call_id_tcp = greh->cid;
+	    //printk("LAN -> WAN TCP src port=%d, dst port=%d \n", ntohs(th->source), ntohs(th->dest));
+	}
+	else if (iph->protocol == IPPROTO_UDP){
+	    uh = (struct udphdr *)((uint8_t *)iph + 20);
+	    pptp_log.call_id_udp = greh->cid;
+	    //printk("UDP src port=%d, dst port=%d", ntohs(uh->source), ntohs(uh->dest));
 	}
-	{
-		unsigned char *ppp_data;
-		int offset = 6;	//l2tp header from 6
-		int ppp_offset=0;
-
-		if(l2tph->ver & 0x4000)
-		{
-			offset += 2;
-		}
-
-		if(l2tph->ver & 0x0200)
-			offset += 2;
-
-		ppp_data = ((char *)l2tph) + offset;
-		ppp_offset = 0;
-		// check PPP IP protocol
-		if (*ppp_data == 0) {
-		    ppp_offset = 1;
-		    ppp_data++;
-		}
-		else if (*ppp_data == 0xff && *(ppp_data+1) == 0x03) {
-		    ppp_offset = 2;
-		    ppp_data += 2;
-		    if (*ppp_data == 0x00) {
-			ppp_offset++;
-			ppp_data++;
-		    }
-		}
-		if (*ppp_data == 0x21 || *ppp_data == 0xfd) {
-		    ppp_offset++;
-		    ppp_type = *ppp_data;
-		}
-		else
-		    ppp_offset = 0;
-
-		if (ppp_offset ==  0)
-		{
-		    return 1;
-		}
-		offset = iph->ihl*4 + 8/*UDP*/ + offset + ppp_offset;	// tunnel IP offset
-		iph_ppp0 = (struct iphdr *)(skb->data + offset + 4 );/*inner IP, 8:UDP in offset*/
-
-		if(!fast_bind)
-		{
-		    l2tpTunnel.saddr = iph_ppp0->saddr;
-		    l2tpTunnel.daddr = iph_ppp0->daddr;
-		}
-		/*get source&dest port to check if binded*/
-		if(iph_ppp0->protocol == IPPROTO_TCP)
-		{
-		    th = (struct tcphdr *)(skb->data + offset + 4 + 20);
-		    addr = ((th->source << 16)|th->dest);
-		    //printk("TCP src port=%d, dst port=%d", ntohs(th->source), ntohs(th->dest));
-		}
-		else if (iph_ppp0->protocol == IPPROTO_UDP)
-		{
-		    uh = (struct udphdr *)(skb->data + offset + 4 + 20);
-		    addr = ((uh->source << 16)|uh->dest);
-		}
-		else
-		{
-		    printk("0.1 Non TCP/UDP to lan, pass up, line %d!!\n", __LINE__);
-		    return 1;
-
-		}
-		// !PPP_IP  pass up
-		if (ppp_type != 0x21)
-		{
-		    printk("3.1 ppp_type !=0x21, pass up, line %d!!\n", __LINE__);
-		    return 1;
-		}
-		else
-		{
-		    int rev = 0;
-		    // header removal section
-
-		    //skb_dump(skb);
-		    rev = is_pptp_l2tp_bind(iph_ppp0->protocol, addr);
-		    //if(fast_bind)
-		    if(rev)
-		    {
-			/*Kurts:memory remove from head*/
-			memcpy(skb->data + 4, skb->data - offset + 4, offset);
-			//printk("afater memmove L2TP header send to PPE\n");
-			//redirect to PPE
-			FOE_AI(skb) = UN_HIT;
-			FOE_MAGIC_TAG(skb) = FOE_MAGIC_PPE;
-			skb_pull(skb, offset);
-			skb_push(skb, 14);
-#if defined (CONFIG_HNAT_V2)
-		/*make mac table transparent*/
-		eth = (struct ethhdr *)skb->data;
-		eth->h_source[0] = 0x01;
-#endif
-		skb->dev = wan_dev;
-		dev_queue_xmit(skb);
-		return 0;
+	//prepare layer3/layer4 info
+	memcpy(&PpeParseResult.iph, iph, sizeof(struct iphdr));
+	if (iph->protocol == IPPROTO_TCP){
+	    LAYER4_HEADER(skb) = ((uint8_t *) iph + (iph->ihl * 4));
+	    th = (struct tcphdr *)LAYER4_HEADER(skb);
+	    memcpy(&PpeParseResult.th, th, sizeof(struct tcphdr));
+	    PpeParseResult.pkt_type = IPV4_HNAPT;
+	    if (DebugLevel >= 1){
+		printk("LAN -> WAN TCP src port=%d, dst port=%d \n", ntohs(th->source), ntohs(th->dest));
 	    }
-	    else{
-		FOE_MAGIC_TAG(skb) = FOE_MAGIC_FASTPATH;
-
-		if(iph_ppp0->protocol == IPPROTO_TCP)
-		{
-		    th = (struct tcphdr *)(skb->data + offset + 4 + 20);
-		    //printk("TCP src port=%d, dst port=%d", ntohs(th->source), ntohs(th->dest));
-		    FOE_SOURCE(skb) = ntohs(th->source);
-		    FOE_DEST(skb) = ntohs(th->dest);
-		}
-		else if (iph_ppp0->protocol == IPPROTO_UDP)
-		{
-		    uh = (struct udphdr *)(skb->data + offset + 4 + 20);
-		    //printk("UDP src port=%d, dst port=%d", ntohs(uh->source), ntohs(uh->dest));
-		    FOE_SOURCE(skb) = ntohs(uh->source);
-		    FOE_DEST(skb) = ntohs(uh->dest);
-		}
-		else
-		{
-		    printk("0.1 return line %d!!\n", __LINE__);
-		    return 1;
-
-		}
+	    if(iph->frag_off & htons(IP_MF|IP_OFFSET)){
+		printk("iph->frag_off  return\n");
+		return 1;
+	    }
+	}else if (iph->protocol == IPPROTO_UDP){
+	    LAYER4_HEADER(skb) = ((uint8_t *) iph + iph->ihl * 4);
+	    uh = (struct udphdr *)LAYER4_HEADER(skb);
+	    memcpy(&PpeParseResult.uh, uh, sizeof(struct udphdr));
+	    PpeParseResult.pkt_type = IPV4_HNAPT;
 
+	    if(iph->frag_off & htons(IP_MF|IP_OFFSET)){
 		return 1;
 	    }
 	}
-
-	LAYER3_HEADER(skb) = skb->data;
-	LAYER4_HEADER(skb) = skb->data;
-
-	FAST_PPTP_PRINT("pass up\n");
+#if defined (CONFIG_HNAT_V2)
+	else if (iph->protocol == IPPROTO_GRE){
+	    /* do nothing */
+	}
+#endif
+	else{
+	    /* Packet format is not supported */
+	    return 1;
 	}
 
-
-
-
+    } else{
 	return 1;
-}
-
+    }
 
- int fast_l2tp_to_wan(struct sk_buff *skb)
-{
-	int	header_len;
-	struct iphdr *iph,*iph_new, iph_newone;
-	struct l2tp_ext_hdr	*l2tph, l2tphone;
-	unsigned char tos;
-	struct vlan_ethhdr *veth=NULL;
-
-	iph = (struct iphdr *)(skb->data + 4);
-	header_len = ETH_HLEN + sizeof(*iph_new) +18 ;
-	if (skb_headroom(skb) < header_len || skb_cloned(skb) || skb_shared(skb))
-	{
-		struct sk_buff *new_skb = skb_realloc_headroom(skb, header_len);
-		if (!new_skb) {
-			printk("%s: skb_realloc_headroom failed!\n", __FUNCTION__);
-			return 1;
-		}
-		dev_kfree_skb(skb);
-		skb = new_skb;
+    if (DebugLevel >= 6){
+	printk("--------------\n");
+	printk("DMAC:%02X:%02X:%02X:%02X:%02X:%02X\n",
+		PpeParseResult.dmac[0], PpeParseResult.dmac[1],
+		PpeParseResult.dmac[2], PpeParseResult.dmac[3],
+		PpeParseResult.dmac[4], PpeParseResult.dmac[5]);
+	printk("SMAC:%02X:%02X:%02X:%02X:%02X:%02X\n",
+		PpeParseResult.smac[0], PpeParseResult.smac[1],
+		PpeParseResult.smac[2], PpeParseResult.smac[3],
+		PpeParseResult.smac[4], PpeParseResult.smac[5]);
+	printk("Eth_Type=%x\n", PpeParseResult.eth_type);
+	if (PpeParseResult.vlan1_gap > 0) {
+	    printk("VLAN1 ID=%x\n", ntohs(PpeParseResult.vlan1));
+	}
+
+	if (PpeParseResult.vlan2_gap > 0) {
+	    printk("VLAN2 ID=%x\n", ntohs(PpeParseResult.vlan2));
+	}
+
+	if (PpeParseResult.pppoe_gap > 0) {
+	    printk("PPPOE Session ID=%x\n",
+		    PpeParseResult.pppoe_sid);
+	    printk("PPP Tag=%x\n", ntohs(PpeParseResult.ppp_tag));
 	}
-
-	// build mac header
-	memcpy(skb_push(skb, header_len), l2tpInfo.mac_header, ETH_HLEN);
-
-	/*add vid 2*/
-	veth = (struct vlan_ethhdr *)(skb->data);
-	veth->h_vlan_proto = htons(ETH_P_8021Q);
-	veth->h_vlan_TCI = htons(0x2);
-	veth->h_vlan_encapsulated_proto = htons(ETH_P_IP);
-
-	// build ip header
-	iph_new = &iph_newone;
-	iph_new->version	=	4;
-	iph_new->ihl		=	sizeof(struct iphdr) >> 2;
-	//iph_new->frag_off	=	frag_off;
-	iph_new->frag_off	=	0x0;
-	iph_new->protocol	=	IPPROTO_UDP;
-	//iph_new->tos		=	tos;
-	iph_new->tos		=	0;
-    	iph_new->daddr		=	l2tpInfo.daddr;
-    	iph_new->saddr		=	l2tpInfo.saddr;
-    	iph_new->ttl 		=	IPDEFTTL;
-    	iph_new->tot_len	=	htons(skb->len - ETH_HLEN -4);
-    	iph_new->id		=	0;
-#if 1
-    	skb->ip_summed		=	CHECKSUM_NONE;
-    	iph_new->check	=	0;
-    	iph_new->check	=	ip_fast_csum((unsigned char *)iph_new, iph_new->ihl);
+#if defined (CONFIG_HNAT_V2)
+	printk("PKT_TYPE=%s\n",
+		PpeParseResult.pkt_type ==
+		0 ? "IPV4_HNAT" : PpeParseResult.pkt_type ==
+		1 ? "IPV4_HNAPT" : PpeParseResult.pkt_type ==
+		3 ? "IPV4_DSLITE" : PpeParseResult.pkt_type ==
+		4 ? "IPV6_ROUTE" : PpeParseResult.pkt_type ==
+		5 ? "IPV6_6RD" : "Unknown");
 #else
-/*for checksum offload*/
-    	skb->ip_summed		=	CHECKSUM_PARTIAL;
+	printk("PKT_TYPE=%s\n",
+		PpeParseResult.pkt_type ==
+		0 ? "IPV4_HNAPT" : PpeParseResult.pkt_type ==
+		1 ? "IPV4_HNAT" : PpeParseResult.pkt_type ==
+		2 ? "IPV6_ROUTE" : "Unknown");
 #endif
-	memcpy(skb->data + ETH_HLEN + 4, &iph_newone, sizeof(iph_newone));
 
-	l2tph = &l2tphone;
-    	l2tph->source	=	l2tpInfo.source;
-    	l2tph->dest	=	l2tpInfo.dest;
-	l2tph->len	=	htons(skb->len - ETH_HLEN- 4 - 20);;
-	l2tph->checksum =	0;
-	l2tph->type	=	0x0200;
-	l2tph->tid	=	l2tpInfo.tid;
-	l2tph->sid	=	l2tpInfo.sid;
-	l2tph->addr_control =	0x03ff;
-	l2tph->protocol	=	0x2100;
-    	memcpy(skb->data+ETH_HLEN+sizeof(struct iphdr)+4, &l2tphone, sizeof(struct l2tp_ext_hdr));
-
-	skb->dev =	wan_dev;
+	if (PpeParseResult.pkt_type == IPV4_HNAT) {
+	    printk("SIP=%s\n",
+		    Ip2Str(ntohl(PpeParseResult.iph.saddr)));
+	    printk("DIP=%s\n",
+		    Ip2Str(ntohl(PpeParseResult.iph.daddr)));
+	    printk("TOS=%x\n", ntohs(PpeParseResult.iph.tos));
+	} else if (PpeParseResult.pkt_type == IPV4_HNAPT) {
+	    printk("SIP=%s\n",
+		    Ip2Str(ntohl(PpeParseResult.iph.saddr)));
+	    printk("DIP=%s\n",
+		    Ip2Str(ntohl(PpeParseResult.iph.daddr)));
+	    printk("TOS=%x\n", ntohs(PpeParseResult.iph.tos));
+
+	    if (PpeParseResult.iph.protocol == IPPROTO_TCP) {
+		printk("TCP SPORT=%d\n", ntohs(PpeParseResult.th.source));
+		printk("TCP DPORT=%d\n", ntohs(PpeParseResult.th.dest));
+	    }else if(PpeParseResult.iph.protocol == IPPROTO_UDP) {
+		printk("UDP SPORT=%d\n", ntohs(PpeParseResult.uh.source));
+		printk("UDP DPORT=%d\n", ntohs(PpeParseResult.uh.dest));
+	    }
+	}
+	}
 
-	FOE_AI(skb) = UN_HIT;
-	dev_queue_xmit(skb);
-	return 0;
+	return 0;/*0 means OK here*/
 }
 
 int32_t L2tpToWanParseLayerInfo(struct sk_buff * skb)
 {
 
-	struct vlan_hdr *vh = NULL;
-	struct ethhdr *eth = NULL;
-	struct iphdr *iph = NULL;
-	struct iphdr *iph_ppp0 = NULL;
-	struct ipv6hdr *ip6h = NULL;
-	struct tcphdr *th = NULL;
-	struct udphdr *uh = NULL;
+    struct vlan_hdr *vh = NULL;
+    struct ethhdr *eth = NULL;
+    struct iphdr *iph = NULL;
+    struct iphdr *iph_ppp0 = NULL;
+    struct tcphdr *th = NULL;
+    struct udphdr *uh = NULL;
 
-	struct l2tp_header  *l2tph = NULL;
-	unsigned short *tunnel_id = NULL;
-	unsigned short *session_id = NULL;
-	unsigned char *ppp_data;
-
-	int offset = 6;	//l2tp header from 6
-	int ppp_offset=0;
-	unsigned char ppp_type=0;
+    struct hnat_l2tp_parse  *l2tph = NULL;
+    uint16_t *tunnel_id = NULL;	
+    uint16_t *session_id = NULL;
+    uint8_t *ppp_format;	
+
+    int32_t offset		   = 6;	//l2tp header from 6 
+    int32_t ppp_length	   = 0;
+    uint8_t ppp_protocol = 0;
 #ifdef CONFIG_RAETH_HW_VLAN_TX
-	struct vlan_hdr pseudo_vhdr;
+    struct vlan_hdr pseudo_vhdr;
 #endif
 
-	memset(&PpeParseResult, 0, sizeof(PpeParseResult));
-
-/*let dst to cpu mac*/
-	//skb_dump(skb);
-
-	eth = (struct ethhdr *)(skb->data);
-	iph_ppp0 = (struct iphdr *)(skb->data + 14 + 4);
+    memset(&PpeParseResult, 0, sizeof(PpeParseResult));
 
+    /*let dst to cpu mac*/
+    eth = (struct ethhdr *)(skb->data);
+    iph_ppp0 = (struct iphdr *)(skb->data + 14 + VLAN_LEN);
+    memcpy(PpeParseResult.smac, eth->h_dest, ETH_ALEN);
+    memcpy(PpeParseResult.dmac, eth->h_source, ETH_ALEN);
+    PpeParseResult.smac[0] = 0x01;
 
+    uh = (struct udphdr *)(skb->data + 14 + (iph_ppp0->ihl*4) + VLAN_LEN);
+    l2tph = (struct hnat_l2tp_parse *)(skb->data + 14 + (iph_ppp0->ihl*4) + VLAN_LEN + 8);
 
-	memcpy(PpeParseResult.smac, eth->h_dest, ETH_ALEN);
-	memcpy(PpeParseResult.dmac, eth->h_source, ETH_ALEN);
-	PpeParseResult.smac[0] = 0x01;
-
-	uh = (struct udp_hdr *)(skb->data + 14 + (iph_ppp0->ihl*4) + 4);
-	l2tph = (struct l2tp_header *)(skb->data + 14 + (iph_ppp0->ihl*4) + 4 + 8);
+    if(ntohs(uh->dest)!=1701) /*l2f port:1701*/
+	return 1;
 
-	if(ntohs(uh->dest)!=1701) /*port:1701*/
-	{
-		return 1;
-	}
 
-	if(ntohs(l2tph->ver) & 0x4000)
-	{
-		offset += 2;
-	}
+    if(ntohs(l2tph->ver) & 0x4000)
+	offset += 2;
 
-	if(ntohs(l2tph->ver) & 0x0200)
-		offset += 2;
+    if(ntohs(l2tph->ver) & 0x0200)
+	offset += 2;
 
-	tunnel_id = (unsigned short *)(skb->data + 14 + (iph_ppp0->ihl*4) + 4 + 8 + offset - 4);
-	session_id = (unsigned short *)(skb->data + 14 + (iph_ppp0->ihl*4) + 4 + 8 + offset - 2);
+    tunnel_id = (uint16_t *)(skb->data + 14 + (iph_ppp0->ihl*4) + VLAN_LEN + 8 + offset - 4);
+    session_id = (uint16_t *)(skb->data + 14 + (iph_ppp0->ihl*4) + VLAN_LEN + 8 + offset - 2);
 
-    if (DebugLevel >= 1) {
-	printk("tunnel_id is 0x%x\n", tunnel_id);
-	printk("offset is 0x%d\n", offset);
+    if (DebugLevel >= 1){
+	printk("tunnel_id is 0x%x\n", *tunnel_id);
+	printk("h2tp header offset is 0x%d\n", offset);
+	printk("VLAN_LEN is 0x%d\n", VLAN_LEN);
     }
-#if 1
-/*log l2tp info*/
-    l2tpInfo.tid = *tunnel_id;
-    l2tpInfo.sid = *session_id;
-    l2tpInfo.saddr = iph_ppp0->saddr;
-    l2tpInfo.daddr = iph_ppp0->daddr;
-    l2tpInfo.source = uh->source;
-    l2tpInfo.dest = uh->dest;
-    memcpy(l2tpInfo.mac_header, eth->h_dest, ETH_ALEN);
-    memcpy(&l2tpInfo.mac_header[6], eth->h_source, ETH_ALEN);
-
-    if (DebugLevel >= 1) {
-	printk("l2tpInfo.sid is 0x%4x\n", l2tpInfo.sid);
-	printk("l2tpInfo.tid is 0x%4x\n", l2tpInfo.tid);
+    /* log l2tp info */	
+    l2tp_log.tid = *tunnel_id;
+    l2tp_log.sid = *session_id;
+    l2tp_log.saddr = iph_ppp0->saddr;
+    l2tp_log.daddr = iph_ppp0->daddr;
+    l2tp_log.source = uh->source;
+    l2tp_log.dest = uh->dest;
+    memcpy(l2tp_log.eth_header, eth->h_dest, ETH_ALEN);
+    memcpy(&l2tp_log.eth_header[6], eth->h_source, ETH_ALEN);
+
+    if (DebugLevel >= 1){
+	printk("l2tp_log.sid is 0x%4x\n", l2tp_log.sid);
+	printk("l2tp_log.tid is 0x%4x\n", l2tp_log.tid);
     }
-#endif
-	PpeParseResult.eth_type = eth->h_proto;
+    PpeParseResult.eth_type = eth->h_proto;
+    ppp_format = ((char *)l2tph) + offset;				
 
-	ppp_data = ((char *)l2tph) + offset;
-	ppp_offset = 0;
+    /* parse PPP length and check inside IP protocol */
+    ppp_length = GetPppLength(ppp_format, &ppp_protocol);
 
-	// check PPP IP protocol
-	if (*ppp_data == 0) {
-		ppp_offset = 1;
-		ppp_data++;
-	}
-	else if (*ppp_data == 0xff && *(ppp_data+1) == 0x03) {
-		ppp_offset = 2;
-		ppp_data += 2;
-		if (*ppp_data == 0)
-		{
-			ppp_offset++;
-			ppp_data++;
-		}
-	}
-	if (*ppp_data == 0x21 || *ppp_data == 0xfd) {
-				ppp_offset++;
-				ppp_type = *ppp_data;
-	}
-	else
-		ppp_offset = 0;
-
-	//printk("l2tp ppp_offset is 0x%d\n", ppp_offset);
-	if (ppp_offset ==  0)
-			return 1;
+    if (ppp_length ==  0) 
+	return 1;
 
-	offset = iph_ppp0->ihl*4+ 8 + offset + ppp_offset;	// tunnel IP offset + udp
+    offset = iph_ppp0->ihl*4+ 8 + offset + ppp_length;	// tunnel IP offset + udp	
 
-	if (ppp_type != 0x21)
-	{
-            printk("3.1 ppp_type !=0x21, pass up, line %d!!\n", __LINE__);
-	    return 1;
-	}
+    if (ppp_protocol != PPP_IP){						
+	printk("3.1 ppp_protocol != IP, return, line %d!!\n", __LINE__);
+	return 1;				
+    }
 
-	if (DebugLevel >= 1)
-	{
-		printk("l2tp offset is 0x%d\n", offset);
-	}
+    if (DebugLevel >= 1) 
+	printk("l2tp offset is 0x%d\n", offset);
 
-	//skb_dump(skb);
-	if (is8021Q(PpeParseResult.eth_type) || isSpecialTag(PpeParseResult.eth_type) || isHwVlanTx(skb)) {
+    if (is8021Q(PpeParseResult.eth_type) || isSpecialTag(PpeParseResult.eth_type) || isHwVlanTx(skb)){
 
 #ifdef CONFIG_RAETH_HW_VLAN_TX
-		PpeParseResult.vlan1_gap = 0;
-		PpeParseResult.vlan_layer++;
-		pseudo_vhdr.h_vlan_TCI = htons(vlan_tx_tag_get(skb));
-		pseudo_vhdr.h_vlan_encapsulated_proto = eth->h_proto;
-		vh = (struct vlan_hdr *)&pseudo_vhdr;
+	PpeParseResult.vlan1_gap = 0;
+	PpeParseResult.vlan_layer++;
+	pseudo_vhdr.h_vlan_TCI = htons(vlan_tx_tag_get(skb));
+	pseudo_vhdr.h_vlan_encapsulated_proto = eth->h_proto;
+	vh = (struct vlan_hdr *)&pseudo_vhdr;
 #else
-		PpeParseResult.vlan1_gap = VLAN_HLEN;
-		PpeParseResult.vlan_layer++;
-		vh = (struct vlan_hdr *)(skb->data + ETH_HLEN);
+	/* For MT7621 GE1 only case */
+	PpeParseResult.vlan1_gap = VLAN_LEN;
+	PpeParseResult.vlan_layer++;
+	vh = (struct vlan_hdr *)(skb->data + ETH_HLEN);
 #endif
-		PpeParseResult.vlan1 = vh->h_vlan_TCI;
-		PpeParseResult.eth_type = vh->h_vlan_encapsulated_proto;
-	}
-
-
-	//printk("LAN -> WAN set layer2 start addr\n");
-	/* set layer2 start addr, original L2 MAC */
-	LAYER2_HEADER(skb) = skb->data;
+	PpeParseResult.vlan1 = vh->h_vlan_TCI;
+	PpeParseResult.eth_type = vh->h_vlan_encapsulated_proto;
+    }
 
+    /* set layer2 start addr, original L2 MAC */
+    LAYER2_HEADER(skb) = skb->data;
 
-	/* set layer3 start addr, inner IP */
-	LAYER3_HEADER(skb) =
-	    (skb->data + offset +ETH_HLEN + PpeParseResult.vlan1_gap +
-	     PpeParseResult.vlan2_gap);
+    /* set layer3 start addr, inner IP */
+    LAYER3_HEADER(skb) =
+	(skb->data + offset +ETH_HLEN + PpeParseResult.vlan1_gap +
+	 PpeParseResult.vlan2_gap);
+
+    if (DebugLevel >= 1) 
+	printk("LAN -> WAN set layer4 start addr\n");
+
+    /* set layer4 start addr */
+    if ((PpeParseResult.eth_type == htons(ETH_P_IP))){
+	iph = (struct iphdr *)LAYER3_HEADER(skb);
+	/* prepare layer3/layer4 info */
+	memcpy(&PpeParseResult.iph, iph, sizeof(struct iphdr));
+	if (iph->protocol == IPPROTO_TCP){
+	    LAYER4_HEADER(skb) = ((uint8_t *) iph + (iph->ihl * 4));
+	    th = (struct tcphdr *)LAYER4_HEADER(skb);
+	    memcpy(&PpeParseResult.th, th, sizeof(struct tcphdr));
+	    PpeParseResult.pkt_type = IPV4_HNAPT;
+	    if (DebugLevel >= 1){
+		printk("LAN -> WAN TCP src port=%d, dst port=%d \n", ntohs(th->source), ntohs(th->dest));
+	    }
+	    if(iph->frag_off & htons(IP_MF|IP_OFFSET)){
+		printk("iph->frag_off  return\n");
+		return 1;
+	    }
+	} else if (iph->protocol == IPPROTO_UDP){
+	    LAYER4_HEADER(skb) = ((uint8_t *) iph + iph->ihl * 4);
+	    uh = (struct udphdr *)LAYER4_HEADER(skb);
+	    memcpy(&PpeParseResult.uh, uh, sizeof(struct udphdr));
+	    PpeParseResult.pkt_type = IPV4_HNAPT;
 
-	if (DebugLevel >= 1)
-	{
-		printk("LAN -> WAN set layer4 start addr\n");
+	    if(iph->frag_off & htons(IP_MF|IP_OFFSET)){
+		printk("iph->frag_off  return\n");
+		return 1;
+	    }
 	}
-	/* set layer4 start addr */
-	//printk("PpeParseResult.eth_type = 0x%x\n",  ntohs(PpeParseResult.eth_type));
-	if ((PpeParseResult.eth_type == htons(ETH_P_IP))) {
-		iph = (struct iphdr *)LAYER3_HEADER(skb);
-		//prepare layer3/layer4 info
-		memcpy(&PpeParseResult.iph, iph, sizeof(struct iphdr));
-		if (iph->protocol == IPPROTO_TCP) {
-			LAYER4_HEADER(skb) = ((uint8_t *) iph + (iph->ihl * 4));
-			th = (struct tcphdr *)LAYER4_HEADER(skb);
-			memcpy(&PpeParseResult.th, th, sizeof(struct tcphdr));
-			PpeParseResult.pkt_type = IPV4_HNAPT;
-			if (DebugLevel >= 1) {
-				printk("LAN -> WAN TCP src port=%d, dst port=%d \n", ntohs(th->source), ntohs(th->dest));
-			}
-			if(iph->frag_off & htons(IP_MF|IP_OFFSET)) {
-			        printk("iph->frag_off  return\n");
-				return 1;
-			}
-		} else if (iph->protocol == IPPROTO_UDP) {
-			LAYER4_HEADER(skb) = ((uint8_t *) iph + iph->ihl * 4);
-			uh = (struct udphdr *)LAYER4_HEADER(skb);
-			memcpy(&PpeParseResult.uh, uh, sizeof(struct udphdr));
-			PpeParseResult.pkt_type = IPV4_HNAPT;
-
-			if(iph->frag_off & htons(IP_MF|IP_OFFSET)) {
-			        printk("iph->frag_off  return\n");
-				return 1;
-			}
-		}
 #if defined (CONFIG_HNAT_V2)
-		else if (iph->protocol == IPPROTO_GRE) {
-			/* do nothing */
-		}
-#endif
-		else {
-			/* Packet format is not supported */
-			return 1;
-		}
-
+	else if (iph->protocol == IPPROTO_GRE){
+	    /* do nothing */
 	}
-	else
-	{
-		return 1;
+#endif
+	else{
+	    /* Packet format is not supported */
+	    return 1;
 	}
 
-	if (DebugLevel >= 6) {
-		printk("--------------\n");
-		printk("DMAC:%02X:%02X:%02X:%02X:%02X:%02X\n",
-		       PpeParseResult.dmac[0], PpeParseResult.dmac[1],
-		       PpeParseResult.dmac[2], PpeParseResult.dmac[3],
-		       PpeParseResult.dmac[4], PpeParseResult.dmac[5]);
-		printk("SMAC:%02X:%02X:%02X:%02X:%02X:%02X\n",
-		       PpeParseResult.smac[0], PpeParseResult.smac[1],
-		       PpeParseResult.smac[2], PpeParseResult.smac[3],
-		       PpeParseResult.smac[4], PpeParseResult.smac[5]);
-		printk("Eth_Type=%x\n", PpeParseResult.eth_type);
-		if (PpeParseResult.vlan1_gap > 0) {
-			printk("VLAN1 ID=%x\n", ntohs(PpeParseResult.vlan1));
-		}
-
-		if (PpeParseResult.vlan2_gap > 0) {
-			printk("VLAN2 ID=%x\n", ntohs(PpeParseResult.vlan2));
-		}
+    } 
+    else{
+	return 1;
+    }
 
-		if (PpeParseResult.pppoe_gap > 0) {
-			printk("PPPOE Session ID=%x\n",
-			       PpeParseResult.pppoe_sid);
-			printk("PPP Tag=%x\n", ntohs(PpeParseResult.ppp_tag));
-		}
+    if (DebugLevel >= 6) 
+    {
+	printk("--------------\n");
+	printk("DMAC:%02X:%02X:%02X:%02X:%02X:%02X\n",
+		PpeParseResult.dmac[0], PpeParseResult.dmac[1],
+		PpeParseResult.dmac[2], PpeParseResult.dmac[3],
+		PpeParseResult.dmac[4], PpeParseResult.dmac[5]);
+	printk("SMAC:%02X:%02X:%02X:%02X:%02X:%02X\n",
+		PpeParseResult.smac[0], PpeParseResult.smac[1],
+		PpeParseResult.smac[2], PpeParseResult.smac[3],
+		PpeParseResult.smac[4], PpeParseResult.smac[5]);
+	printk("Eth_Type=%x\n", PpeParseResult.eth_type);
+	if (PpeParseResult.vlan1_gap > 0) {
+	    printk("VLAN1 ID=%x\n", ntohs(PpeParseResult.vlan1));
+	}
+
+	if (PpeParseResult.vlan2_gap > 0) {
+	    printk("VLAN2 ID=%x\n", ntohs(PpeParseResult.vlan2));
+	}
+
+	if (PpeParseResult.pppoe_gap > 0) {
+	    printk("PPPOE Session ID=%x\n",
+		    PpeParseResult.pppoe_sid);
+	    printk("PPP Tag=%x\n", ntohs(PpeParseResult.ppp_tag));
+	}
 #if defined (CONFIG_HNAT_V2)
-		printk("PKT_TYPE=%s\n",
-		       PpeParseResult.pkt_type ==
-		       0 ? "IPV4_HNAT" : PpeParseResult.pkt_type ==
-		       1 ? "IPV4_HNAPT" : PpeParseResult.pkt_type ==
-		       3 ? "IPV4_DSLITE" : PpeParseResult.pkt_type ==
-		       4 ? "IPV6_ROUTE" : PpeParseResult.pkt_type ==
-		       5 ? "IPV6_6RD" : "Unknown");
+	printk("PKT_TYPE=%s\n",
+		PpeParseResult.pkt_type ==
+		0 ? "IPV4_HNAT" : PpeParseResult.pkt_type ==
+		1 ? "IPV4_HNAPT" : PpeParseResult.pkt_type ==
+		3 ? "IPV4_DSLITE" : PpeParseResult.pkt_type ==
+		4 ? "IPV6_ROUTE" : PpeParseResult.pkt_type ==
+		5 ? "IPV6_6RD" : "Unknown");
 #else
-		printk("PKT_TYPE=%s\n",
-		       PpeParseResult.pkt_type ==
-		       0 ? "IPV4_HNAPT" : PpeParseResult.pkt_type ==
-		       1 ? "IPV4_HNAT" : PpeParseResult.pkt_type ==
-		       2 ? "IPV6_ROUTE" : "Unknown");
+	printk("PKT_TYPE=%s\n",
+		PpeParseResult.pkt_type ==
+		0 ? "IPV4_HNAPT" : PpeParseResult.pkt_type ==
+		1 ? "IPV4_HNAT" : PpeParseResult.pkt_type ==
+		2 ? "IPV6_ROUTE" : "Unknown");
 #endif
 
-		if (PpeParseResult.pkt_type == IPV4_HNAT) {
-			printk("SIP=%s\n",
+	if (PpeParseResult.pkt_type == IPV4_HNAT) {
+	    printk("SIP=%s\n",
+		    Ip2Str(ntohl(PpeParseResult.iph.saddr)));
+	    printk("DIP=%s\n",
+		    Ip2Str(ntohl(PpeParseResult.iph.daddr)));
+	    printk("TOS=%x\n", ntohs(PpeParseResult.iph.tos));
+	} else if (PpeParseResult.pkt_type == IPV4_HNAPT) {
+	    printk("SIP=%s\n",
 			       Ip2Str(ntohl(PpeParseResult.iph.saddr)));
 			printk("DIP=%s\n",
 			       Ip2Str(ntohl(PpeParseResult.iph.daddr)));
 			printk("TOS=%x\n", ntohs(PpeParseResult.iph.tos));
-		} else if (PpeParseResult.pkt_type == IPV4_HNAPT) {
-			printk("SIP=%s\n",
-			       Ip2Str(ntohl(PpeParseResult.iph.saddr)));
-			printk("DIP=%s\n",
-			       Ip2Str(ntohl(PpeParseResult.iph.daddr)));
-			printk("TOS=%x\n", ntohs(PpeParseResult.iph.tos));
-
+			
 			if (PpeParseResult.iph.protocol == IPPROTO_TCP) {
 			    printk("TCP SPORT=%d\n", ntohs(PpeParseResult.th.source));
 			    printk("TCP DPORT=%d\n", ntohs(PpeParseResult.th.dest));
@@ -1550,7 +1285,6 @@
 			}
 		}
 	}
-
 	return 0;/*0 means OK here*/
 }
 
Index: linux-2.6.36/net/nat/hw_nat/fast_path.h
===================================================================
--- linux-2.6.36.orig/net/nat/hw_nat/fast_path.h	2014-03-28 15:00:47.302531591 +0800
+++ linux-2.6.36/net/nat/hw_nat/fast_path.h	2014-03-28 15:00:47.546531591 +0800
@@ -1,53 +1,109 @@
-
 #ifndef _FASTPATH_WANTED
 #define _FASTPATH_WANTED
 
-
 #define PPTP_TCP_PORT           1723
-#define PPTP_GRE_VERSION        0x1
-#define PPTP_GRE_PROTOCOL       0x880B
-
 #define PPP_ADDRESS_CONTROL     0xff03
-#define PPP_PROTOCOL		0x0021
+/* gre header structure: -------------------------------------------- */
+
+#define PPTP_GRE_PROTO  0x880B
+#define PPTP_GRE_VER    0x1
+
+#define PPTP_GRE_FLAG_C 0x80
+#define PPTP_GRE_FLAG_R 0x40
+#define PPTP_GRE_FLAG_K 0x20
+#define PPTP_GRE_FLAG_S 0x10
+#define PPTP_GRE_FLAG_A 0x80
+
+#define PPTP_GRE_IS_C(f) ((f)&PPTP_GRE_FLAG_C)
+#define PPTP_GRE_IS_R(f) ((f)&PPTP_GRE_FLAG_R)
+#define PPTP_GRE_IS_K(f) ((f)&PPTP_GRE_FLAG_K)
+#define PPTP_GRE_IS_S(f) ((f)&PPTP_GRE_FLAG_S)
+#define PPTP_GRE_IS_A(f) ((f)&PPTP_GRE_FLAG_A)
+
+/* 16 bytes GRE header */
+struct pptp_gre_header {
+    u8 flags;             /* bitfield */
+    u8 ver;                       /* should be PPTP_GRE_VER (enhanced GRE) */
+    u16 protocol;         /* should be PPTP_GRE_PROTO (ppp-encaps) */
+    u16 payload;      /* size of ppp payload, not inc. gre header */
+    u16 cid;          /* peer's call_id for this session */
+    u32 seq;              /* sequence number.  Present if S==1 */
+    u32 ack;              /* seq number of highest packet recieved by */
+    /*  sender in this session */
+} __packed;
+
+
+struct hnat_pptp 
+{
+    uint32_t tx_seqno;
+    uint32_t rx_seqno;
+    uint32_t saddr;
+    uint32_t daddr;
+    uint16_t call_id;
+    uint16_t call_id_udp;/*tcp udp with different ID*/
+    uint16_t call_id_tcp;
+    uint16_t tx_ip_id;
+    uint8_t eth_header[ETH_HLEN];
+    uint32_t key;/*MT7620:add key*/
+};
+
+/*L2TP*/
+struct hnat_l2tp
+{
+    uint32_t daddr;                     /* DIP */
+    uint32_t saddr;			    /* SIP */
+    uint16_t tid;                     /* Tunnel ID */
+    uint16_t sid;                     /* Session ID */
+    uint16_t source;                  /* UDP source port */
+    uint16_t dest;                    /* UDP dest port */
+    uint8_t eth_header[ETH_HLEN];
+};
 
-#define PPTP_GRE_FLAG_C		0x80
-#define PPTP_GRE_FLAG_R		0x40
-#define PPTP_GRE_FLAG_K		0x20
-#define PPTP_GRE_FLAG_S		0x10
-#define PPTP_GRE_FLAG_A		0x80
-
-#define PPTP_GRE_IS_C(f)	((f)&PPTP_GRE_FLAG_C)
-#define PPTP_GRE_IS_R(f)	((f)&PPTP_GRE_FLAG_R)
-#define PPTP_GRE_IS_K(f)	((f)&PPTP_GRE_FLAG_K)
-#define PPTP_GRE_IS_S(f)	((f)&PPTP_GRE_FLAG_S)
-#define PPTP_GRE_IS_A(f)	((f)&PPTP_GRE_FLAG_A)
-
-
-struct pptp_gre_hdr {
-	unsigned char  flags;		/* bitfield */
-	unsigned char  version;		/* should be PPTP_GRE_VER (enhanced GRE) */
-	unsigned short protocol;		/* should be PPTP_GRE_PROTO (ppp-encaps) */
-	unsigned short payload_len;	/* size of ppp payload, not inc. gre header */
-	unsigned short call_id;		/* peer's call_id for this session */
-	unsigned int seq;		/* sequence number.  Present if S==1 */
-	unsigned int ack;		/* seq number of highest packet recieved by */
-					/*  sender in this session */
+struct l2tp_add_hdr
+{
+    uint16_t source; /* UDP */
+    uint16_t dest;
+    uint16_t len;
+    uint16_t checksum;
+    uint16_t type; /* L2TP */
+    uint16_t tid;
+    uint16_t sid;
 };
 
-#define PPTP_CONTROL_PACKET     1
-#define PPTP_MGMT_PACKET        2
+struct hnat_l2tp_parse
+{
+    uint16_t ver;                   /* Packets Type */
+    uint16_t length;                /* Length (Optional)*/
+    uint16_t tid;                   /* Tunnel ID */
+    uint16_t sid;                   /* Session ID */
+};
+
+struct ppp_hdr {
+	uint16_t addr_ctrl;
+	uint16_t protocol;
+};
+
+
+
+
+/* MT7621 2 GMAC*/
+#ifdef CONFIG_GE_RGMII_INTERNAL_P4_AN
+#define VLAN_LEN       0
+#else
+#define VLAN_LEN       4
+#endif
 
-int	fast_pptp_to_lan(struct sk_buff **pskb);
-int	fast_pptp_to_wan(struct sk_buff *pskb);
-int	fast_l2tp_to_lan(struct sk_buff **pskb);
-int	fast_l2tp_to_wan(struct sk_buff *pskb);
+int32_t	HnatPptpLan(struct sk_buff *skb);
+int32_t HnatPptpWan(struct sk_buff *skb);
+int32_t	HnatL2tpLan(struct sk_buff *skb);
+int32_t	HnatL2tpWan(struct sk_buff *skb);
 int32_t PktGenInitMod(void);
 int32_t PptpToLanParseLayerInfo(struct sk_buff * skb);
 int32_t PptpToWanParseLayerInfo(struct sk_buff * skb);
 int32_t L2tpToWanParseLayerInfo(struct sk_buff * skb);
-void	pptp_l2tp_fdb_update(unsigned char protocol, unsigned int addr, unsigned int foe_hash_index);
+void	pptp_l2tp_fdb_update(uint8_t protocol, uint32_t addr, uint32_t foe_hash_index);
 int32_t SendHashPkt(struct sk_buff *pskb);
 int32_t SendL2TPHashPkt(struct sk_buff *pskb);
-int	fast_pptp_init(void);
-int	fast_pptp_clean(void);
+int32_t	HnatPptpL2tpInit(void);
+int32_t	HnatPptpL2tpClean(void);
 #endif
Index: linux-2.6.36/net/nat/hw_nat/hwnat_ioctl.c
===================================================================
--- linux-2.6.36.orig/net/nat/hw_nat/hwnat_ioctl.c	2014-03-28 15:00:47.306531591 +0800
+++ linux-2.6.36/net/nat/hw_nat/hwnat_ioctl.c	2014-03-28 15:00:47.546531591 +0800
@@ -218,13 +218,30 @@
 #if defined (CONFIG_HNAT_V2)
 int32_t PpeGetAGCnt(struct hwnat_ac_args * opt3)
 {
+#ifdef CONFIG_RA_HW_NAT_ACCNT_MAINTAINER
+	extern struct hwnat_ac_args ac_info[64];
+#if defined (CONFIG_RALINK_MT7620)
+        ac_info[opt3->ag_index].ag_byte_cnt += RegRead(AC_BASE + 1 * 8);      /* Low bytes */
+        ac_info[opt3->ag_index].ag_pkt_cnt  += RegRead(AC_BASE +  1 * 8 + 4);  /* High bytes */
+#elif defined (CONFIG_RALINK_MT7621)
+        ac_info[opt3->ag_index].ag_byte_cnt += RegRead(AC_BASE + 1 * 16);             /* 64bit bytes cnt */
+        ac_info[opt3->ag_index].ag_byte_cnt += (RegRead(AC_BASE + 1 * 16 + 4) << 32);
+	ac_info[opt3->ag_index].ag_byte_cnt += ((unsigned long long)(RegRead(AC_BASE + opt3->ag_index * 16 + 4)) << 32);
+        ac_info[opt3->ag_index].ag_pkt_cnt  += RegRead(AC_BASE +  1 * 16 + 8);                /* 32bites packet cnt */
+#endif
+        opt3->ag_byte_cnt = ac_info[opt3->ag_index].ag_byte_cnt;
+        opt3->ag_pkt_cnt = ac_info[opt3->ag_index].ag_pkt_cnt;
+#else
 #if defined (CONFIG_RALINK_MT7620)
         opt3->ag_byte_cnt = RegRead(AC_BASE + opt3->ag_index * 8);       /* Low bytes */
-        opt3->ag_pkt_cnt = RegRead(AC_BASE + opt3->ag_index * 8 + 4);  /* High bytes */
+        opt3->ag_pkt_cnt = RegRead(AC_BASE + opt3->ag_index * 8 + 4);    /* High bytes */
 #elif defined (CONFIG_RALINK_MT7621)
         opt3->ag_byte_cnt = RegRead(AC_BASE + opt3->ag_index * 16);     /* 64bit bytes cnt */
+	opt3->ag_byte_cnt += ((unsigned long long)(RegRead(AC_BASE + opt3->ag_index * 16 + 4)) << 32);
         opt3->ag_pkt_cnt = RegRead(AC_BASE + opt3->ag_index * 16 + 8);  /* 32bites packet cnt */
 #endif
+#endif
+
 
         return HWNAT_SUCCESS;
 }
Index: linux-2.6.36/net/nat/hw_nat/hwnat_ioctl.h
===================================================================
--- linux-2.6.36.orig/net/nat/hw_nat/hwnat_ioctl.h	2014-03-28 15:00:47.306531591 +0800
+++ linux-2.6.36/net/nat/hw_nat/hwnat_ioctl.h	2014-03-28 15:00:47.546531591 +0800
@@ -169,8 +169,8 @@
 #if defined (CONFIG_HNAT_V2)
 struct hwnat_ac_args {
 	unsigned char ag_index;
-	unsigned int ag_byte_cnt;
-	unsigned int ag_pkt_cnt;
+	unsigned long long ag_byte_cnt;
+	unsigned long long ag_pkt_cnt;
 	enum hwnat_status result;
 };
 #endif
Index: linux-2.6.36/net/nat/hw_nat/pptp_l2tp_fdb.c
===================================================================
--- linux-2.6.36.orig/net/nat/hw_nat/pptp_l2tp_fdb.c	2014-03-28 15:00:47.306531591 +0800
+++ linux-2.6.36/net/nat/hw_nat/pptp_l2tp_fdb.c	2014-03-28 15:00:47.546531591 +0800
@@ -1,211 +1,198 @@
-//#include <linux/kernel.h>
-
-//#include <linux/init.h>
-//#include <linux/spinlock.h>
-//#include <linux/times.h>
 #include <linux/netdevice.h>
-//#include <linux/etherdevice.h>
 #include <linux/jhash.h>
-
-//#include <linux/list.h>
 #include "pptp_l2tp_fdb.h"
 #include "foe_fdb.h"
 
 
 spinlock_t                      pptp_l2tp_hash_lock;
 struct hlist_head               pptp_l2tp_hash[PPTP_L2TP_HASH_SIZE];
-
 static u32 fdb_salt __read_mostly;
-
 extern uint32_t         DebugLevel;
 
 
 
-int pptp_l2tp_addr_hash(unsigned int key)
+int32_t pptp_l2tp_addr_hash(uint32_t key)
 {
-	/* use 1 byte of OUI cnd 3 bytes of NIC */
-	//u32 key = get_unaligned((u32 *)(addr));
-	return jhash_1word(key, fdb_salt) & (PPTP_L2TP_HASH_SIZE - 1);
+    return jhash_1word(key, fdb_salt) & (PPTP_L2TP_HASH_SIZE - 1);
 }
 
 void fdb_delete(struct pptp_l2tp_fdb_entry *f)
 {
-        //printk("fdb_delete %p\n\r", (void*)f);
-	hlist_del_rcu(&f->hlist);
-        kfree(f);
+    //printk("fdb_delete %p\n\r", (void*)f);
+    hlist_del_rcu(&f->hlist);
+    kfree(f);
 }
 
 
 /* Completely flush all dynamic entries in forwarding database.*/
 void pptp_l2tp_fdb_flush(void)
 {
-	int i;
-	struct FoeEntry *foe_entry = NULL;
+    int32_t i;
+    struct FoeEntry *foe_entry = NULL;
 
-	spin_lock_bh(&pptp_l2tp_hash_lock);
-	for (i = 0; i < PPTP_L2TP_HASH_SIZE; i++) {
-		struct pptp_l2tp_fdb_entry *f;
-		struct hlist_node *h, *n;
-		hlist_for_each_entry_safe(f, h, n, &pptp_l2tp_hash[i], hlist) {
-
-	    	    foe_entry = &PpeFoeBase[f->hash_index];
-			if (foe_entry->bfib1.state != BIND){
-				fdb_delete(f);
-				//FoeDumpEntry(f->hash_index);
-			}
-		}
+    spin_lock_bh(&pptp_l2tp_hash_lock);
+    for (i = 0; i < PPTP_L2TP_HASH_SIZE; i++) {
+	struct pptp_l2tp_fdb_entry *f;
+	struct hlist_node *h, *n;
+	hlist_for_each_entry_safe(f, h, n, &pptp_l2tp_hash[i], hlist) {
+
+	    foe_entry = &PpeFoeBase[f->hash_index];
+	    if (foe_entry->bfib1.state != BIND){
+		fdb_delete(f);
+		//FoeDumpEntry(f->hash_index);
+	    }
 	}
-	spin_unlock_bh(&pptp_l2tp_hash_lock);
+    }
+    spin_unlock_bh(&pptp_l2tp_hash_lock);
 }
 
 
 
 struct pptp_l2tp_fdb_entry *pptp_l2tp_fdb_find(struct hlist_head *head,
-						    unsigned int addr)
+	uint32_t addr)
 {
-	struct hlist_node *h;
-	struct pptp_l2tp_fdb_entry *fdb;
+    struct hlist_node *h;
+    struct pptp_l2tp_fdb_entry *fdb;
 
-        //DBGPRINT_RAW(RT_DEBUG_INFO,("ucast_fdb_find called\n\r"));
-	hlist_for_each_entry_rcu(fdb, h, head, hlist) {
-		if (fdb->addr == addr){
-			return fdb;
-		}
+    hlist_for_each_entry_rcu(fdb, h, head, hlist) {
+	if (fdb->addr == addr){
+	    return fdb;
 	}
-	return NULL;
+    }
+    return NULL;
 }
 
 struct pptp_l2tp_fdb_entry *pptp_l2tp_fdb_create(struct hlist_head *head,
-					       unsigned int foe_hash,
-					       unsigned int addr,
-					       unsigned char protocol)
-{
-	struct pptp_l2tp_fdb_entry *fdb = NULL;
-
-
-        fdb = kzalloc(sizeof(struct pptp_l2tp_fdb_entry), GFP_ATOMIC);
-	if (DebugLevel >= 1) {
-		printk("get a fdb space at %p\n", (void*)fdb);
-	}
-	if (fdb) {
-		//memcpy(fdb->addr, addr, ETH_ALEN);
-		hlist_add_head_rcu(&fdb->hlist, head);
-		fdb->addr = addr;
-		fdb->hash_index = foe_hash;
-		fdb->protocol = protocol;
-	}
-	return fdb;
+	uint32_t foe_hash,
+	uint32_t addr,
+	uint8_t protocol)
+{
+    struct pptp_l2tp_fdb_entry *fdb = NULL;
+
+    fdb = kzalloc(sizeof(struct pptp_l2tp_fdb_entry), GFP_ATOMIC);
+    if (DebugLevel >= 1) {
+	printk("get a fdb space at %p\n", (void*)fdb);
+    }
+    if (fdb) {
+	//memcpy(fdb->addr, addr, ETH_ALEN);
+	hlist_add_head_rcu(&fdb->hlist, head);
+	fdb->addr = addr;
+	fdb->hash_index = foe_hash;
+	fdb->protocol = protocol;
+    }
+    return fdb;
 }
 
 
 /*
  *
  *
- *
- *  upate mac address on tei
+ *  update port address, protocol  
  *  protocol: UDP (0x11) or TCP (0x6)
  *
  *
  */
-#if 1
-void pptp_l2tp_fdb_update(unsigned char protocol, unsigned int addr, unsigned int foe_hash_index)
+void pptp_l2tp_fdb_update(uint8_t protocol, uint32_t addr, uint32_t foe_hash_index)
 {
-	struct hlist_head *head = &pptp_l2tp_hash[pptp_l2tp_addr_hash(addr)];
-	struct pptp_l2tp_fdb_entry *fdb;
+    struct hlist_head *head = &pptp_l2tp_hash[pptp_l2tp_addr_hash(addr)];
+    struct pptp_l2tp_fdb_entry *fdb;
 
-	fdb = pptp_l2tp_fdb_find(head, addr);
-	if (likely(fdb)) {
+    fdb = pptp_l2tp_fdb_find(head, addr);
+    if (likely(fdb)) {
 
-		if (DebugLevel >= 1) {
-			printk("pptp l2tp entry already exist\n");
-		}
-	} else {
-		spin_lock(&pptp_l2tp_hash_lock);
-		if (DebugLevel >= 1) {
-			printk("create an entry #%d protocol=0x%2x addr=0x%4x\n",foe_hash_index, protocol, addr);
-		}
-		pptp_l2tp_fdb_create(head, foe_hash_index, addr, protocol);
-		spin_unlock(&pptp_l2tp_hash_lock);
-	  /* flush time out FDB */
-		pptp_l2tp_fdb_flush();
+	if (DebugLevel >= 1) {
+	    printk("pptp l2tp entry already exist\n");  
 	}
-}
-
-int is_pptp_l2tp_bind(unsigned char protocol, unsigned int addr)
-{
-	struct hlist_head *head = &pptp_l2tp_hash[pptp_l2tp_addr_hash(addr)];
-	struct pptp_l2tp_fdb_entry *fdb = NULL;
-	struct FoeEntry *foe_entry = NULL;
-
-	//printk("is_pptp_l2tp_bind protocol=0x%2x addr=0x%4x\n", protocol, addr);
-	fdb = pptp_l2tp_fdb_find(head, addr);
-	if (fdb) {
-		if(fdb->protocol == protocol){
-			foe_entry = &PpeFoeBase[fdb->hash_index];
-			//FoeDumpEntry(fdb->hash_index);
-			if (foe_entry->bfib1.state == BIND)
-				return 1;
-		}
+    } else {
+	spin_lock(&pptp_l2tp_hash_lock);
+	if (DebugLevel >= 1) {
+	    printk("create an entry #%d protocol=0x%2x addr=0x%4x\n",foe_hash_index, protocol, addr);
 	}
-	else {
-		return 0;
+	pptp_l2tp_fdb_create(head, foe_hash_index, addr, protocol);
+	spin_unlock(&pptp_l2tp_hash_lock);
+	/* flush time out FDB */
+	pptp_l2tp_fdb_flush();
+    }
+}
+
+int32_t is_pptp_l2tp_bind(uint8_t protocol, uint32_t addr)
+{
+    struct hlist_head *head = &pptp_l2tp_hash[pptp_l2tp_addr_hash(addr)];
+    struct pptp_l2tp_fdb_entry *fdb = NULL;
+    struct FoeEntry *foe_entry = NULL;
+
+    fdb = pptp_l2tp_fdb_find(head, addr);
+    if (fdb) {
+	if(fdb->protocol == protocol){
+	    foe_entry = &PpeFoeBase[fdb->hash_index];
+	    //FoeDumpEntry(fdb->hash_index);
+	    if (foe_entry->bfib1.state == BIND){
+		//printk("pptp_l2tp_bind protocol=0x%2x addr=0x%4x\n", protocol, addr);
+		return 1;
+	    }
 	}
+    } 
+    else {
 	return 0;
+    }
+    return 0;
 }
 
-#endif
 
 
 /*
- * @brief:
- *
- * @param:
+ * @brief: 
  *
- * @return:
+ * @param: 
+ *         
+ * @return: 
  */
-int pptp_l2tp_fdb_dump(void)
+int32_t pptp_l2tp_fdb_dump(void)
 {
-	int i, num = 0;
-	struct hlist_node *h;
-	struct pptp_l2tp_fdb_entry *f;
-	struct FoeEntry *foe_entry = NULL;
-
-	rcu_read_lock();
-	for (i = 0; i < PPTP_L2TP_HASH_SIZE; i++) {
-		hlist_for_each_entry_rcu(f, h, &pptp_l2tp_hash[i], hlist) {
-		foe_entry = &PpeFoeBase[f->hash_index];
-			if (foe_entry->bfib1.state != BIND)
-			{
-				continue;
-			}
-			else{
-			    printk("pptp l2tp bind entry address %x\n", f->addr);
-			}
-
-		}
-	}
-
-	rcu_read_unlock();
+    int32_t i = 0;
+    struct hlist_node *h;
+    struct pptp_l2tp_fdb_entry *f;
+    struct FoeEntry *foe_entry = NULL;
+
+    rcu_read_lock();
+    for (i = 0; i < PPTP_L2TP_HASH_SIZE; i++) 
+    {
+	hlist_for_each_entry_rcu(f, h, &pptp_l2tp_hash[i], hlist) 
+	{
+	    foe_entry = &PpeFoeBase[f->hash_index];
+	    if (foe_entry->bfib1.state != BIND)    
+	    {
+		continue;
+	    }
+	    else{
+		printk("pptp l2tp bind entry address %x\n", f->addr);
+	    }
+
+	}
+    }
+    rcu_read_unlock();
+    return 0;
 }
 
 
 
-int pptp_l2tp_addr_delete(const unsigned char *addr)
-{
-	struct hlist_head *head = &pptp_l2tp_hash[pptp_l2tp_addr_hash(addr)];
-	struct pptp_l2tp_fdb_entry *fdb;
-
-
-	fdb = pptp_l2tp_fdb_find(head, addr);
-	if (likely(fdb)) {
-		//spin_lock(&ucast_hash_lock);
-		fdb_delete(fdb);
-		//spin_unlock(&ucast_hash_lock);
-	        return 1;
-	} else {
-		printk("pptp_l2tp_addr_delete fdb no find \n\r");
-	}
-	return 0;
+int32_t pptp_l2tp_addr_delete(uint8_t *addr)
+{
+    struct hlist_head *head = &pptp_l2tp_hash[pptp_l2tp_addr_hash((uint32_t)addr)];
+    struct pptp_l2tp_fdb_entry *fdb;
+
+    fdb = pptp_l2tp_fdb_find(head, (uint32_t)addr);
+    if (likely(fdb)) 
+    {
+	//spin_lock(&ucast_hash_lock);
+	fdb_delete(fdb);
+	//spin_unlock(&ucast_hash_lock);
+	return 1;
+    } else 
+    {
+	printk("pptp_l2tp_addr_delete fdb no find \n\r");
+    }
+    return 0;
 }
 
 
Index: linux-2.6.36/net/nat/hw_nat/pptp_l2tp_fdb.h
===================================================================
--- linux-2.6.36.orig/net/nat/hw_nat/pptp_l2tp_fdb.h	2014-03-28 15:00:47.306531591 +0800
+++ linux-2.6.36/net/nat/hw_nat/pptp_l2tp_fdb.h	2014-03-28 15:00:47.546531591 +0800
@@ -7,7 +7,7 @@
 #define PPTP_L2TP_HASH_BITS 9
 #define PPTP_L2TP_HASH_SIZE (1 << PPTP_L2TP_HASH_BITS)
 
-//typedef unsigned int            u32;
+//typedef uint32_t            u32;
 
 /* -------------------- Structure Definitions -------------------------- */
 
@@ -16,12 +16,12 @@
 
 struct pptp_l2tp_fdb_entry
 {
-    struct hlist_node			hlist;
-    struct rcu_head			rcu;
-    unsigned int			hash_index;
-    unsigned int			addr;/*src port + dst port*/
-    unsigned char			protocol;
-    unsigned char			entry_type;  /*0: Invalid, 1: from ethernet, 2: from WLan, 3: remote??*/
+    struct hlist_node		hlist;
+    struct rcu_head		rcu;
+    uint32_t			hash_index;
+    uint32_t			addr;/*src port + dst port*/
+    uint8_t			protocol;
+    uint8_t			entry_type;  /*0: Invalid, 1: from ethernet, 2: from WLan, 3: remote??*/
 };
 
 
@@ -32,8 +32,8 @@
 /* -------------------- Address Definitions ---------------------------- */
 
 /* -------------------- Function Declaration ---------------------------- */
-void pptp_l2tp_fdb_update(unsigned char protocol, unsigned int addr, unsigned int foe_hash_index);
-int is_pptp_l2tp_bind(unsigned char protocol, unsigned int addr);
+void pptp_l2tp_fdb_update(uint8_t protocol, uint32_t addr, uint32_t foe_hash_index);
+int32_t is_pptp_l2tp_bind(uint8_t protocol, uint32_t addr);
 
 
 
Index: linux-2.6.36/net/nat/hw_nat/ra_nat.c
===================================================================
--- linux-2.6.36.orig/net/nat/hw_nat/ra_nat.c	2014-03-28 15:00:47.530531591 +0800
+++ linux-2.6.36/net/nat/hw_nat/ra_nat.c	2014-03-28 15:02:53.526531576 +0800
@@ -83,6 +83,9 @@
 dma_addr_t		PpePhyFoeBase;
 struct net_device	*DstPort[MAX_IF_NUM];
 PktParseResult		PpeParseResult;
+#ifdef CONFIG_RA_HW_NAT_ACCNT_MAINTAINER
+struct hwnat_ac_args    ac_info[64]; //1 for LAN, 2 for WAN
+#endif
 
 #if 0
 void skb_dump(struct sk_buff* sk) {
@@ -783,8 +786,7 @@
 	if(pptp_fast_path && (skb->len != (124 - 14))){
 	    int ret = 1000;
 		/*remove pptp/l2tp header, tx to PPE*/
-		ret = fast_pptp_to_lan(&skb);
-
+		ret = HnatPptpLan(skb);
 		/*ret 0, remove header ok*/
 		if(ret == 0)
 			return ret;
@@ -793,8 +795,7 @@
 	if(l2tp_fast_path && (skb->len != (124 - 14))){
 	    int ret = 1000;
 		/*remove pptp/l2tp header, tx to PPE*/
-		ret = fast_l2tp_to_lan(&skb);
-
+		ret = HnatL2tpLan(skb);
 		if(ret == 0)
 			return ret;
 	}
@@ -824,13 +825,13 @@
 		/*to ppp0, add pptp/l2tp header and send out*/
 		int ret = 1000;
 		//printk("PPTP LAN->WAN  get bind packet!!\n");
-		ret = fast_pptp_to_wan(skb);
+		ret = HnatPptpWan(skb);
 		return ret;
 	    }
 	    else if(l2tp_fast_path){
 		/*to ppp0, add pptp/l2tp header and send out*/
 		int ret = 1000;
-		ret = fast_l2tp_to_wan(skb);
+		ret = HnatL2tpWan(skb);
 		//printk("L2TP LAN->WAN fast send bind packet and return %d!!\n", ret);
 		return ret;
 	    }
@@ -876,7 +877,7 @@
 		/* Set Layer2 Info */
 		if (PpeFillInL2Info(skb, foe_entry)) {
 			memset(FOE_INFO_START_ADDR(skb), 0, FOE_INFO_LEN);
-			dev_kfree_skb_any(skb);/*kurtis test*/
+			dev_kfree_skb_any(skb);
 			return 0;
 		}
 
@@ -886,7 +887,7 @@
 		/* Set Layer3 Info */
 		if (PpeFillInL3Info(skb, foe_entry)) {
 			memset(FOE_INFO_START_ADDR(skb), 0, FOE_INFO_LEN);
-			dev_kfree_skb_any(skb);/*kurtis test*/
+			dev_kfree_skb_any(skb);
 			return 0;
 		}
 
@@ -896,7 +897,7 @@
 		/* Set Layer4 Info */
 		if (PpeFillInL4Info(skb, foe_entry)) {
 			memset(FOE_INFO_START_ADDR(skb), 0, FOE_INFO_LEN);
-			dev_kfree_skb_any(skb);/*kurtis test*/
+			dev_kfree_skb_any(skb);
 			return 0;
 		}
 
@@ -904,7 +905,7 @@
 		//if (PpeSetForcePortInfo(skb, foe_entry, gmac_no)) {
 		if (PpeSetForcePortInfo(skb, foe_entry, 1)) {
 			memset(FOE_INFO_START_ADDR(skb), 0, FOE_INFO_LEN);
-			dev_kfree_skb_any(skb);/*kurtis test*/
+			dev_kfree_skb_any(skb);
 			return 0;
 		}
 		/* Enter binding state */
@@ -3740,42 +3741,45 @@
 }
 #endif
 
-#if defined (CONFIG_RALINK_MT7620)
-
-void update_foe_ts_timer_handler(unsigned long unused);
-DEFINE_TIMER(update_foe_ts_timer, update_foe_ts_timer_handler, 0, 0);
+#ifdef CONFIG_RA_HW_NAT_ACCNT_MAINTAINER
+void update_foe_ac_timer_handler(unsigned long unused);
+DEFINE_TIMER(update_foe_ac_timer, update_foe_ac_timer_handler, 0, 0);
 
-void update_foe_ts_timer_handler(unsigned long unused)
+void update_foe_ac_timer_handler(unsigned long unused)
 {
-    unsigned int val = 0;
-    val =  *(volatile unsigned int *)0xb0100010;
-    val &= 0x0000ffff;
-    val += 0x1;
-    val |= 0x180000;
-    *(volatile unsigned int *)0xb0100010 =  val;
+#if defined (CONFIG_RALINK_MT7620)
+        ac_info[1].ag_byte_cnt += RegRead(AC_BASE + 1 * 8);      /* Low bytes */
+        ac_info[1].ag_pkt_cnt  += RegRead(AC_BASE +  1 * 8 + 4); /* High bytes */
+        ac_info[2].ag_byte_cnt += RegRead(AC_BASE + 2 * 8);      /* Low bytes */
+        ac_info[2].ag_pkt_cnt  += RegRead(AC_BASE +  2 * 8 + 4); /* High bytes */
+#elif defined (CONFIG_RALINK_MT7621)
+        ac_info[1].ag_byte_cnt += RegRead(AC_BASE + 1 * 16);		  /* 64bit bytes cnt */
+        ac_info[1].ag_byte_cnt += ((unsigned long long)(RegRead(AC_BASE + 1 * 16 + 4)) << 32);  /* 64bit bytes cnt */
+        ac_info[1].ag_pkt_cnt  += RegRead(AC_BASE +  1 * 16 + 8);	  /* 32bites packet cnt */
+        ac_info[2].ag_byte_cnt += RegRead(AC_BASE + 2 * 16);		  /* 64bit bytes cnt */
+        ac_info[2].ag_byte_cnt += ((unsigned long long)(RegRead(AC_BASE + 2 * 16 + 4)) << 32);  /* 64bit bytes cnt */
+        ac_info[2].ag_pkt_cnt  += RegRead(AC_BASE +  2 * 16 + 8);	  /* 32bites packet cnt */
+#endif
 
-    update_foe_ts_timer.expires = jiffies + HZ;
-    add_timer(&update_foe_ts_timer);
+    update_foe_ac_timer.expires = jiffies + 16 * HZ;
+    add_timer(&update_foe_ac_timer);
 }
+#endif
 
-void foe_ts_update_ebl(int ebl)
+void foe_ac_update_ebl(int ebl)
 {
-    if((RegRead(0xb000000c)&0xFFFF) != 0x0101) {
-	return;
-    }
-
+#ifdef CONFIG_RA_HW_NAT_ACCNT_MAINTAINER
     if(ebl) {
-	update_foe_ts_timer.expires = jiffies + HZ;
-	add_timer(&update_foe_ts_timer);
+	update_foe_ac_timer.expires = jiffies + HZ;
+	add_timer(&update_foe_ac_timer);
     } else {
-	if(timer_pending(&update_foe_ts_timer)) {
-	    del_timer_sync(&update_foe_ts_timer);
+	if(timer_pending(&update_foe_ac_timer)) {
+	    del_timer_sync(&update_foe_ac_timer);
 	}
     }
+#endif
 }
 
-#endif // CONFIG_RALINK_MT7620 //
-
 /*
  * PPE Enabled: GMAC<->PPE<->CPU
  * PPE Disabled: GMAC<->CPU
@@ -3810,6 +3814,7 @@
     PpeSetIpProt();
     PpeSetCacheEbl();
     PpeSetSwVlanChk(0);
+    foe_ac_update_ebl(1);
 
     /* 0~63 Metering group */
     //PpeSetMtrByteInfo(1, 500, 3); //TokenRate=500=500KB/s, MaxBkSize= 3 (32K-1B)
@@ -3853,7 +3858,6 @@
 #endif
 
 #if defined (CONFIG_RALINK_MT7620)
-	foe_ts_update_ebl(1);
 /*For FastPath disable crc check*/
 #if defined (CONFIG_RA_HW_NAT_PPTP_L2TP)
 	RegWrite(0xb0100600, 0x20010000);
@@ -3862,7 +3866,7 @@
 #endif
 
 #if defined (CONFIG_RA_HW_NAT_PPTP_L2TP)
-	fast_pptp_init();
+	HnatPptpL2tpInit();
 #endif
 	NAT_PRINT("Ralink HW NAT Module Enabled!\n");
 	return 0;
@@ -3895,6 +3899,7 @@
     MtrUnRegIoctlHandler();
 #else
     PpeSetSwVlanChk(1);
+    foe_ac_update_ebl(0);
 #endif
 #if defined (CONFIG_RAETH_QDMA) && defined  (CONFIG_PPE_MCAST)
     foe_mcast_entry_del_all();
@@ -3916,11 +3921,8 @@
     class_destroy(hnat_class);
 #endif
 
-#if defined (CONFIG_RALINK_MT7620)
-    foe_ts_update_ebl(0);
-#endif
 #if defined (CONFIG_RA_HW_NAT_PPTP_L2TP)
-	fast_pptp_clean();
+	HnatPptpL2tpClean();
 #endif
 	NAT_PRINT("Ralink HW NAT Module Removed!\n");
 }
