Index: linux-2.6.36/drivers/mtd/Kconfig
===================================================================
--- linux-2.6.36.orig/drivers/mtd/Kconfig
+++ linux-2.6.36/drivers/mtd/Kconfig
@@ -33,6 +33,23 @@ config MTD_TESTS
 	  should normally be compiled as kernel modules. The modules perform
 	  various checks and verifications when loaded.
 
+config MTD_ROOTFS_ROOT_DEV
+        bool "Automatically set 'rootfs' partition to be root filesystem"
+        default y
+
+config MTD_ROOTFS_SPLIT
+        bool "Automatically split 'rootfs' partition for squashfs"
+        default y
+
+config MTD_UIMAGE_SPLIT
+        bool "Automatically split off rootfs from a kernel partition containing a uIma    ge"
+        default y
+
+config MTD_UIMAGE_SPLIT_NAME
+        string "uImage partition name"
+        depends on MTD_UIMAGE_SPLIT
+        default "firmware"
+
 config MTD_CONCAT
 	tristate "MTD concatenating support"
 	help
Index: linux-2.6.36/drivers/mtd/devices/block2mtd.c
===================================================================
--- linux-2.6.36.orig/drivers/mtd/devices/block2mtd.c
+++ linux-2.6.36/drivers/mtd/devices/block2mtd.c
@@ -29,6 +29,8 @@ struct block2mtd_dev {
 	struct block_device *blkdev;
 	struct mtd_info mtd;
 	struct mutex write_mutex;
+	rwlock_t bdev_mutex;
+	char devname[0];
 };
 
 
@@ -81,6 +83,12 @@ static int block2mtd_erase(struct mtd_in
 	size_t len = instr->len;
 	int err;
 
+	read_lock(&dev->bdev_mutex);
+	if (!dev->blkdev) {
+    	err = -EINVAL;
+    	goto done;
+	}
+
 	instr->state = MTD_ERASING;
 	mutex_lock(&dev->write_mutex);
 	err = _block2mtd_erase(dev, from, len);
@@ -93,6 +101,10 @@ static int block2mtd_erase(struct mtd_in
 
 	instr->state = MTD_ERASE_DONE;
 	mtd_erase_callback(instr);
+
+done:
+	read_unlock(&dev->bdev_mutex);
+
 	return err;
 }
 
@@ -104,10 +116,14 @@ static int block2mtd_read(struct mtd_inf
 	struct page *page;
 	int index = from >> PAGE_SHIFT;
 	int offset = from & (PAGE_SIZE-1);
-	int cpylen;
+	int cpylen, err = 0;
+
+	read_lock(&dev->bdev_mutex);
+	if (!dev->blkdev || (from > mtd->size)) {
+    	err = -EINVAL;
+    	goto done;
+	}
 
-	if (from > mtd->size)
-		return -EINVAL;
 	if (from + len > mtd->size)
 		len = mtd->size - from;
 
@@ -122,10 +138,14 @@ static int block2mtd_read(struct mtd_inf
 		len = len - cpylen;
 
 		page = page_read(dev->blkdev->bd_inode->i_mapping, index);
-		if (!page)
-			return -ENOMEM;
-		if (IS_ERR(page))
-			return PTR_ERR(page);
+		if (!page) {
+			err = -ENOMEM;
+			goto done;
+		}
+		if (IS_ERR(page)) {
+			err = PTR_ERR(page);
+			goto done;
+		}
 
 		memcpy(buf, page_address(page) + offset, cpylen);
 		page_cache_release(page);
@@ -136,7 +156,10 @@ static int block2mtd_read(struct mtd_inf
 		offset = 0;
 		index++;
 	}
-	return 0;
+
+done:
+	read_unlock(&dev->bdev_mutex);
+	return err;
 }
 
 
@@ -188,12 +211,20 @@ static int block2mtd_write(struct mtd_in
 		size_t *retlen, const u_char *buf)
 {
 	struct block2mtd_dev *dev = mtd->priv;
-	int err;
+	int err = 0;
+
+	read_lock(&dev->bdev_mutex);
+	if (!dev->blkdev) {
+    	err = -EINVAL;
+    	goto done;
+	}
 
 	if (!len)
-		return 0;
-	if (to >= mtd->size)
-		return -ENOSPC;
+		goto done;
+	if (to >= mtd->size) {
+		err = -ENOSPC;
+		goto done;
+	}
 	if (to + len > mtd->size)
 		len = mtd->size - to;
 
@@ -202,6 +233,9 @@ static int block2mtd_write(struct mtd_in
 	mutex_unlock(&dev->write_mutex);
 	if (err > 0)
 		err = 0;
+
+done:
+	read_unlock(&dev->bdev_mutex);
 	return err;
 }
 
@@ -210,51 +244,29 @@ static int block2mtd_write(struct mtd_in
 static void block2mtd_sync(struct mtd_info *mtd)
 {
 	struct block2mtd_dev *dev = mtd->priv;
-	sync_blockdev(dev->blkdev);
-	return;
-}
 
+	read_lock(&dev->bdev_mutex);
+	if (dev->blkdev)
+		sync_blockdev(dev->blkdev);
+	read_unlock(&dev->bdev_mutex);
 
-static void block2mtd_free_device(struct block2mtd_dev *dev)
-{
-	if (!dev)
 		return;
-
-	kfree(dev->mtd.name);
-
-	if (dev->blkdev) {
-		invalidate_mapping_pages(dev->blkdev->bd_inode->i_mapping,
-					0, -1);
-		close_bdev_exclusive(dev->blkdev, FMODE_READ|FMODE_WRITE);
-	}
-
-	kfree(dev);
 }
 
 
-/* FIXME: ensure that mtd->size % erase_size == 0 */
-static struct block2mtd_dev *add_device(char *devname, int erase_size)
+static int _open_bdev(struct block2mtd_dev *dev)
 {
 	struct block_device *bdev;
-	struct block2mtd_dev *dev;
-	char *name;
-
-	if (!devname)
-		return NULL;
-
-	dev = kzalloc(sizeof(struct block2mtd_dev), GFP_KERNEL);
-	if (!dev)
-		return NULL;
 
 	/* Get a handle on the device */
-	bdev = open_bdev_exclusive(devname, FMODE_READ|FMODE_WRITE, NULL);
+	bdev = open_bdev_exclusive(dev->devname, FMODE_READ|FMODE_WRITE, NULL);
 #ifndef MODULE
 	if (IS_ERR(bdev)) {
 
 		/* We might not have rootfs mounted at this point. Try
 		   to resolve the device name by other means. */
 
-		dev_t devt = name_to_dev_t(devname);
+		dev_t devt = name_to_dev_t(dev->devname);
 		if (devt) {
 			bdev = open_by_devnum(devt, FMODE_WRITE | FMODE_READ);
 		}
@@ -262,17 +274,98 @@ static struct block2mtd_dev *add_device(
 #endif
 
 	if (IS_ERR(bdev)) {
-		ERROR("error: cannot open device %s", devname);
-		goto devinit_err;
+		ERROR("error: cannot open device %s", dev->devname);
+		return 1;
 	}
 	dev->blkdev = bdev;
 
 	if (MAJOR(bdev->bd_dev) == MTD_BLOCK_MAJOR) {
 		ERROR("attempting to use an MTD device as a block device");
-		goto devinit_err;
+		return 1;
 	}
 
+	return 0;
+}
+
+
+static void _close_bdev(struct block2mtd_dev *dev)
+{
+	struct block_device *bdev;
+
+	if (!dev->blkdev)
+		return;
+
+	bdev = dev->blkdev;
+	invalidate_mapping_pages(dev->blkdev->bd_inode->i_mapping, 0, -1);
+	close_bdev_exclusive(dev->blkdev, FMODE_READ|FMODE_WRITE);
+	dev->blkdev = NULL;
+}
+
+static void block2mtd_free_device(struct block2mtd_dev *dev)
+{
+	if (!dev)
+		return;
+
+	kfree(dev->mtd.name);
+	_close_bdev(dev);
+	kfree(dev);
+}
+
+static int block2mtd_refresh(struct mtd_info *mtd)
+{
+	struct block2mtd_dev *dev = mtd->priv;
+	struct block_device *bdev;
+	dev_t devt;
+	int err = 0;
+
+	/* no other mtd function can run at this point */
+	write_lock(&dev->bdev_mutex);
+
+	/* get the device number for the whole disk */
+	devt = MKDEV(MAJOR(dev->blkdev->bd_dev), 0);
+
+	/* close the old block device */
+	_close_bdev(dev);
+
+	/* open the whole disk, issue a partition rescan, then */
+	bdev = open_by_devnum(devt, FMODE_WRITE | FMODE_READ);
+	if (!bdev || !bdev->bd_disk)
+		err = -EINVAL;
+	#ifndef CONFIG_MTD_BLOCK2MTD_MODULE
+	else
+		err = rescan_partitions(bdev->bd_disk, bdev);
+	#endif
+	if (bdev)
+		close_bdev_exclusive(bdev, FMODE_READ|FMODE_WRITE);
+
+	/* try to open the partition block device again */
+	_open_bdev(dev);
+	write_unlock(&dev->bdev_mutex);
+
+	return err;
+}
+
+/* FIXME: ensure that mtd->size % erase_size == 0 */
+static struct block2mtd_dev *add_device(char *devname, int erase_size, char *mtdname)
+{
+	struct block2mtd_dev *dev;
+	struct mtd_partition *part;
+	char *name;
+
+	if (!devname)
+		return NULL;
+
+	dev = kzalloc(sizeof(struct block2mtd_dev) + strlen(devname) + 1, GFP_KERNEL);
+	if (!dev)
+		return NULL;
+
+	strcpy(dev->devname, devname);
+
+	if (_open_bdev(dev))
+		goto devinit_err;
+
 	mutex_init(&dev->write_mutex);
+	rwlock_init(&dev->bdev->mutex);
 
 	/* Setup the MTD structure */
 	/* make the name contain the block device in */
@@ -294,6 +387,7 @@ static struct block2mtd_dev *add_device(
 	dev->mtd.read = block2mtd_read;
 	dev->mtd.priv = dev;
 	dev->mtd.owner = THIS_MODULE;
+	dev->mtd.refresh_device = block2mtd_refresh;
 
 	if (add_mtd_device(&dev->mtd)) {
 		/* Device didnt get added, so free the entry */
Index: linux-2.6.36/drivers/mtd/mtdchar.c
===================================================================
--- linux-2.6.36.orig/drivers/mtd/mtdchar.c
+++ linux-2.6.36/drivers/mtd/mtdchar.c
@@ -33,7 +33,7 @@
 
 #include <linux/mtd/mtd.h>
 #include <linux/mtd/map.h>
-
+#include <linux/mtd/partitions.h>
 #include <asm/uaccess.h>
 
 #define MTD_INODE_FS_MAGIC 0x11307854
@@ -855,6 +855,14 @@ static int mtd_ioctl(struct file *file, 
 		break;
 	}
 
+#ifdef CONFIG_MTD_PARTITIONS
+	case MTDREFRESH:
+	{
+		ret = refresh_mtd_partitions(mtd);
+		break;
+	}
+#endif
+
 	default:
 		ret = -ENOTTY;
 	}
Index: linux-2.6.36/drivers/mtd/mtdpart.c
===================================================================
--- linux-2.6.36.orig/drivers/mtd/mtdpart.c
+++ linux-2.6.36/drivers/mtd/mtdpart.c
@@ -28,6 +28,8 @@
 #include <linux/list.h>
 #include <linux/kmod.h>
 #include <linux/mtd/mtd.h>
+#include <linux/root_dev.h>
+#include <linux/magic.h>
 #include <linux/mtd/partitions.h>
 
 /* Our partition linked list */
@@ -41,12 +43,14 @@ struct mtd_part {
 	struct list_head list;
 };
 
+static void mtd_partition_split(struct mtd_info *master, struct mtd_part *part);
+
 /*
  * Given a pointer to the MTD object in the mtd_part structure, we can retrieve
  * the pointer to that structure with this macro.
  */
 #define PART(x)  ((struct mtd_part *)(x))
-
+#define IS_PART(mtd) (mtd->read == part_read)
 
 /*
  * MTD methods which simply translate the effective address and pass through
@@ -524,6 +528,258 @@ out_register:
 	return slave;
 }
 
+
+#ifdef CONFIG_MTD_ROOTFS_SPLIT
+#define ROOTFS_SPLIT_NAME "rootfs_data"
+#define ROOTFS_REMOVED_NAME "<removed>"
+
+struct squashfs_super_block {
+	__le32 s_magic;
+	__le32 pad0[9];
+	__le64 bytes_used;
+};
+
+
+static int split_squashfs(struct mtd_info *master, int offset, int *split_offset)
+{
+	struct squashfs_super_block sb;
+	int len, ret;
+
+	ret = master->read(master, offset, sizeof(sb), &len, (void *) &sb);
+	if (ret || (len != sizeof(sb))) {
+		printk(KERN_ALERT "split_squashfs: error occured while reading "
+			"from \"%s\"\n", master->name);
+			return -EINVAL;
+	}
+
+	if (SQUASHFS_MAGIC != le32_to_cpu(sb.s_magic) ) {
+		printk(KERN_ALERT "split_squashfs: no squashfs found in \"%s\"\n",
+				master->name);
+		*split_offset = 0;
+		return 0;
+	}
+
+	if (le64_to_cpu((sb.bytes_used)) <= 0) {
+		printk(KERN_ALERT "split_squashfs: squashfs is empty in \"%s\"\n",
+				master->name);
+		*split_offset = 0;
+		return 0;
+	}
+
+	len = (u32) le64_to_cpu(sb.bytes_used);
+	len += (offset & 0x000fffff);
+	len +=  (master->erasesize - 1);
+	len &= ~(master->erasesize - 1);
+	len -= (offset & 0x000fffff);
+	*split_offset = offset + len;
+
+	return 0;
+}
+
+static int split_rootfs(struct mtd_info *master, struct mtd_info *rpart, const struct mtd_partition *part)
+{
+	struct mtd_partition *dpart;
+	struct mtd_part *slave = NULL;
+	int split_offset = 0;
+	int ret;
+
+	ret = split_squashfs(master, part->offset, &split_offset);
+	if (ret)
+		return ret;
+
+	if (split_offset <= 0)
+		return 0;
+
+	dpart = kmalloc(sizeof(*part)+sizeof(ROOTFS_SPLIT_NAME)+1, GFP_KERNEL);
+	if (dpart == NULL) {
+		printk(KERN_INFO "split_squashfs: no memory for partition \"%s\"\n",
+				ROOTFS_SPLIT_NAME);
+		return -ENOMEM;
+	}
+
+	memcpy(dpart, part, sizeof(*part));
+	dpart->name = (unsigned char *)&dpart[1];
+	strcpy(dpart->name, ROOTFS_SPLIT_NAME);
+
+	dpart->size -= split_offset - dpart->offset;
+	dpart->offset = split_offset;
+
+	if (dpart == NULL)
+		return 1;
+
+	printk(KERN_INFO "mtd: partition \"%s\" created automatically, ofs=%llX, len=%llX \n",
+		ROOTFS_SPLIT_NAME, dpart->offset, dpart->size);
+
+	slave = add_one_partition(master, dpart, 0, split_offset);
+	if (!slave) {
+		kfree(dpart);
+		return -ENOMEM;
+	}
+	rpart->split = &slave->mtd;
+
+	return 0;
+}
+
+static int refresh_rootfs_split(struct mtd_info *mtd)
+{
+	struct mtd_partition tpart;
+	struct mtd_part *part;
+	char *name;
+	//int index = 0;
+	int offset, size;
+	int ret;
+
+	part = PART(mtd);
+
+	/* check for the new squashfs offset first */
+	ret = split_squashfs(part->master, part->offset, &offset);
+	if (ret)
+		return ret;
+
+	if ((offset > 0) && !mtd->split) {
+		printk(KERN_INFO "%s: creating new split partition for \"%s\"\n", __func__, mtd->name);
+		/* if we don't have a rootfs split partition, create a new one */
+		tpart.name = (char *) mtd->name;
+		tpart.size = mtd->size;
+		tpart.offset = part->offset;
+
+		return split_rootfs(part->master, &part->mtd, &tpart);
+	} else if ((offset > 0) && mtd->split) {
+		/* update the offsets of the existing partition */
+		size = mtd->size + part->offset - offset;
+
+		part = PART(mtd->split);
+		part->offset = offset;
+		part->mtd.size = size;
+		printk(KERN_INFO "%s: %s partition \"" ROOTFS_SPLIT_NAME "\", offset: 0x%06x (0x%06x)\n",
+				__func__, (!strcmp(part->mtd.name, ROOTFS_SPLIT_NAME) ? "updating" : "creating"),
+				(u32) part->offset, (u32) part->mtd.size);
+		name = kmalloc(sizeof(ROOTFS_SPLIT_NAME) + 1, GFP_KERNEL);
+		strcpy(name, ROOTFS_SPLIT_NAME);
+		part->mtd.name = name;
+	} else if ((offset <= 0) && mtd->split) {
+		printk(KERN_INFO "%s: removing partition \"%s\"\n", __func__, mtd->split->name);
+
+		/* mark existing partition as removed */
+		part = PART(mtd->split);
+		name = kmalloc(sizeof(ROOTFS_SPLIT_NAME) + 1, GFP_KERNEL);
+		strcpy(name, ROOTFS_REMOVED_NAME);
+		part->mtd.name = name;
+		part->offset = 0;
+		part->mtd.size = 0;
+	}
+
+	return 0;
+}
+#endif /* CONFIG_MTD_ROOTFS_SPLIT */
+
+
+#define OPENWRT_ROOTFS_NAME "rootfs"
+#define UBOOT_MAGIC  0x27051956
+
+static int split_firmware(struct mtd_info *master,
+	struct mtd_info *rpart, const struct mtd_partition * part)
+{
+	struct {
+			__be32 magic;
+			__be32 pad[2];
+			__be32 size;
+	} hdr;
+	size_t uimage_len;
+	size_t rootfs_len;
+	int ret;
+	struct mtd_partition * rootfs_partition;
+	struct mtd_partition * unused_partition;
+	struct mtd_part * slave = NULL;
+	struct mtd_part * spart;
+
+	printk(KERN_NOTICE "mtd: split_firmware\n");
+
+	printk(KERN_NOTICE "mtd: firmware_partition->size   0x%llx\n", part->size);
+	printk(KERN_NOTICE "mtd: firmware_partition->offset 0x%llx\n", part->offset);
+
+	if (master->read(master, part->offset, sizeof(hdr), &uimage_len, (void *) &hdr))
+		return;
+
+	if (uimage_len != sizeof(hdr) || hdr.magic != cpu_to_be32(UBOOT_MAGIC))
+		return;
+
+	uimage_len = be32_to_cpu(hdr.size) + 0x40;
+	printk(KERN_NOTICE "mtd: uimage_len %d\n", uimage_len);
+
+	spart = PART(rpart);
+	rootfs_partition = kmalloc(sizeof(struct mtd_partition)+sizeof(OPENWRT_ROOTFS_NAME)+1, GFP_KERNEL);
+	if (rootfs_partition == NULL) {
+		printk(KERN_INFO "split_firmware: no memory for partition \"%s\"\n",
+				OPENWRT_ROOTFS_NAME);
+		return -ENOMEM;
+	}
+
+	memcpy(rootfs_partition, part, sizeof(*part));
+	rootfs_partition->name = (unsigned char *)&rootfs_partition[1];
+	strcpy(rootfs_partition->name, OPENWRT_ROOTFS_NAME);
+
+	rootfs_partition->size   = part->size - uimage_len;
+	rootfs_partition->offset = part->offset + uimage_len;
+	printk(KERN_NOTICE "mtd: rootfs_partition->size   0x%llx\n", rootfs_partition->size);
+	printk(KERN_NOTICE "mtd: rootfs_partition->offset 0x%llx\n", rootfs_partition->offset);
+
+	if (rootfs_partition == NULL)
+		return 1;
+
+	printk(KERN_INFO "mtd: partition \"%s\" created automatically, ofs=%llX, len=%llX \n",
+			OPENWRT_ROOTFS_NAME, rootfs_partition->offset, rootfs_partition->size);
+
+	slave = add_one_partition(master, rootfs_partition, 0, uimage_len);
+	if (!slave) {
+		kfree(rootfs_partition);
+		return -ENOMEM;
+	}
+	rpart->split = &slave->mtd;
+
+	//------------------------------
+	ret = split_squashfs(master, rootfs_partition->offset, &rootfs_len);
+	rootfs_len -= rootfs_partition->offset;
+	printk(KERN_NOTICE "mtd: rootfs_len %d\n", rootfs_len);
+	if (ret)
+		return ret;
+
+	if (rootfs_len <= 0)
+		return 0;
+
+	unused_partition = kmalloc(sizeof(struct mtd_partition)+sizeof(ROOTFS_SPLIT_NAME)+1, GFP_KERNEL);
+	if (unused_partition == NULL) {
+		printk(KERN_INFO "split_squashfs: no memory for partition \"%s\"\n",
+				ROOTFS_SPLIT_NAME);
+		return -ENOMEM;
+	}
+
+	memcpy(unused_partition, rootfs_partition, sizeof(*rootfs_partition));
+	unused_partition->name = (unsigned char *)&unused_partition[1];
+	strcpy(unused_partition->name, ROOTFS_SPLIT_NAME);
+
+	unused_partition->size   = part->size - uimage_len - rootfs_len;
+	unused_partition->offset = rootfs_partition->offset + rootfs_len;
+	printk(KERN_NOTICE "mtd: unused_partition->size   0x%llx\n", unused_partition->size);
+	printk(KERN_NOTICE "mtd: unused_partition->offset 0x%llx\n", unused_partition->offset);
+
+	if (unused_partition == NULL)
+		return 1;
+
+	printk(KERN_INFO "mtd: partition \"%s\" created automatically, ofs=%llX, len=%llX \n",
+			ROOTFS_SPLIT_NAME, unused_partition->offset, unused_partition->size);
+
+	slave = add_one_partition(master, unused_partition, 0, rootfs_len);
+	if (!slave) {
+		kfree(unused_partition);
+		return -ENOMEM;
+	}
+	rpart->split = &slave->mtd;
+
+	return 0;
+}
+
+
 /*
  * This function, given a master MTD object and a partition table, creates
  * and registers slave MTD objects which are bound to the master according to
@@ -539,7 +795,7 @@ int add_mtd_partitions(struct mtd_info *
 {
 	struct mtd_part *slave;
 	uint64_t cur_offset = 0;
-	int i;
+	int i, ret __maybe_unused;
 
 	printk(KERN_NOTICE "Creating %d MTD partitions on \"%s\":\n", nbparts, master->name);
 
@@ -547,6 +803,29 @@ int add_mtd_partitions(struct mtd_info *
 		slave = add_one_partition(master, parts + i, i, cur_offset);
 		if (!slave)
 			return -ENOMEM;
+#if 1 // hua.shao
+		if (!strcmp(parts[i].name, "firmware")) {
+			printk(KERN_NOTICE "mtd: try split firmware partition\n");
+			split_firmware(master, &slave->mtd, &parts[i]);
+		}
+
+#else  // hua.shao
+		if (!strcmp(parts[i].name, OPENWRT_ROOTFS_NAME)) {
+			printk(KERN_NOTICE "mtd: found rootfs partition\n");
+#ifdef CONFIG_MTD_ROOTFS_ROOT_DEV
+			if (ROOT_DEV == 0) {
+				printk(KERN_NOTICE "mtd: partition \"rootfs\" "
+						"set to be root filesystem\n");
+				ROOT_DEV = MKDEV(MTD_BLOCK_MAJOR, slave->mtd.index);
+			}
+#endif
+#ifdef CONFIG_MTD_ROOTFS_SPLIT
+			ret = split_rootfs(master, &slave->mtd, &parts[i]);
+			/* if (ret == 0)
+					j++; */
+#endif
+		}
+#endif
 		cur_offset = slave->offset + slave->mtd.size;
 	}
 
@@ -554,6 +833,33 @@ int add_mtd_partitions(struct mtd_info *
 }
 EXPORT_SYMBOL(add_mtd_partitions);
 
+int refresh_mtd_partitions(struct mtd_info *mtd)
+{
+	int ret = 0;
+
+	if (IS_PART(mtd)) {
+		struct mtd_part *part;
+		struct mtd_info *master;
+
+		part = PART(mtd);
+		master = part->master;
+		if (master->refresh_device)
+			ret = master->refresh_device(master);
+	}
+
+	if (!ret && mtd->refresh_device)
+		ret = mtd->refresh_device(mtd);
+
+#ifdef CONFIG_MTD_ROOTFS_SPLIT
+	if (!ret && IS_PART(mtd) && !strcmp(mtd->name, "rootfs"))
+		refresh_rootfs_split(mtd);
+#endif
+
+	return 0;
+}
+
+EXPORT_SYMBOL_GPL(refresh_mtd_partitions);
+
 static DEFINE_SPINLOCK(part_parser_lock);
 static LIST_HEAD(part_parsers);
 
Index: linux-2.6.36/drivers/mtd/ralink/ralink_spi.c
===================================================================
--- linux-2.6.36.orig/drivers/mtd/ralink/ralink_spi.c
+++ linux-2.6.36/drivers/mtd/ralink/ralink_spi.c
@@ -38,6 +38,36 @@ extern u32 get_surfboard_sysclk(void) ;
 #include <linux/spi/flash.h>
 #endif
 
+#if 1 // openwrt test
+
+static struct mtd_partition rt2880_partitions[] = {
+    {
+           name:           "ALL",
+           size:           MTDPART_SIZ_FULL,
+           offset:         0,
+    },
+	/* Put your own partition definitions here */
+    {
+           name:           "Bootloader",
+           size:           MTD_BOOT_PART_SIZE,
+           offset:         0,
+    }, {
+           name:           "Config",
+           size:           MTD_CONFIG_PART_SIZE,
+           offset:         MTDPART_OFS_APPEND
+    }, {
+           name:           "Factory",
+           size:           MTD_FACTORY_PART_SIZE,
+           offset:         MTDPART_OFS_APPEND
+    }, {
+           name:           "firmware",
+           size:           0x800000,
+           offset:         0x50000,
+    }
+};
+
+#else
+
 static struct mtd_partition rt2880_partitions[] = {
 	{
                 name:           "ALL",
@@ -93,7 +123,7 @@ static struct mtd_partition rt2880_parti
         }
 };
 
-
+#endif
 
 /******************************************************************************
  * SPI FLASH elementray definition and function
Index: linux-2.6.36/include/linux/mtd/mtd.h
===================================================================
--- linux-2.6.36.orig/include/linux/mtd/mtd.h
+++ linux-2.6.36/include/linux/mtd/mtd.h
@@ -110,6 +110,7 @@ struct mtd_oob_ops {
 	uint8_t		*oobbuf;
 };
 
+struct mtd_info;
 struct mtd_info {
 	u_char type;
 	uint32_t flags;
@@ -251,6 +252,9 @@ struct mtd_info {
 	struct device dev;
 	int usecount;
 
+	int (*refresh_device)(struct mtd_info *mtd);
+	struct mtd_info *split;
+
 	/* If the driver is something smart, like UBI, it may need to maintain
 	 * its own reference counting. The below functions are only for driver.
 	 * The driver may register its callbacks. These callbacks are not
Index: linux-2.6.36/include/linux/mtd/partitions.h
===================================================================
--- linux-2.6.36.orig/include/linux/mtd/partitions.h
+++ linux-2.6.36/include/linux/mtd/partitions.h
@@ -34,6 +34,7 @@
  * erasesize aligned (e.g. use MTDPART_OFS_NEXTBLK).
  */
 
+struct mtd_partition;
 struct mtd_partition {
 	char *name;			/* identifier string */
 	uint64_t size;			/* partition size */
@@ -51,6 +52,7 @@ struct mtd_info;
 
 int add_mtd_partitions(struct mtd_info *, const struct mtd_partition *, int);
 int del_mtd_partitions(struct mtd_info *);
+int refresh_mtd_partitions(struct mtd_info *);
 
 /*
  * Functions dealing with the various ways of partitioning the space
Index: linux-2.6.36/include/mtd/mtd-abi.h
===================================================================
--- linux-2.6.36.orig/include/mtd/mtd-abi.h
+++ linux-2.6.36/include/mtd/mtd-abi.h
@@ -126,6 +126,7 @@ struct otp_info {
 #define MEMWRITEOOB64		_IOWR('M', 21, struct mtd_oob_buf64)
 #define MEMREADOOB64		_IOWR('M', 22, struct mtd_oob_buf64)
 #define MEMISLOCKED		_IOR('M', 23, struct erase_info_user)
+#define MTDREFRESH		_IO('M', 24)
 
 /*
  * Obsolete legacy interface. Keep it in order not to break userspace
Index: linux-2.6.36/arch/mips/ralink/Kconfig
===================================================================
--- linux-2.6.36.orig/arch/mips/ralink/Kconfig
+++ linux-2.6.36/arch/mips/ralink/Kconfig
@@ -315,15 +315,15 @@ config MTD_PHYSMAP_BUSWIDTH
 
 choice
 	prompt "Root File System Type"
-	default RT2880_ROOTFS_IN_RAM
+	default RT2880_ROOTFS_IN_FLASH
 
 config  RT2880_ROOTFS_IN_RAM
         bool "RootFS_in_RAM"
 	select BLK_DEV_INITRD
 	select BLK_DEV_RAM
 
-#config  RT2880_ROOTFS_IN_FLASH
-#        bool "RootFS_in_FLASH"
+config  RT2880_ROOTFS_IN_FLASH
+        bool "RootFS_in_FLASH"
 endchoice
 
 config BLK_DEV_RAM_SIZE
Index: linux-2.6.36/arch/mips/ralink/cmdline.c
===================================================================
--- linux-2.6.36.orig/arch/mips/ralink/cmdline.c
+++ linux-2.6.36/arch/mips/ralink/cmdline.c
@@ -41,6 +41,9 @@
 
 #include <asm/bootinfo.h>
 
+#if 1 //hua.shao for openwrt test
+char rt2880_cmdline[]="console=ttyS1,57600n8 root=/dev/mtdblock5";
+#else
 #if defined (CONFIG_RT2880_ROOTFS_IN_FLASH)
 #ifdef CONFIG_SYSFS
 char rt2880_cmdline[]="console=ttyS1,57600n8 root=/dev/mtdblock5";
@@ -52,6 +55,7 @@ char rt2880_cmdline[]="console=ttyS1,576
 #else
 #error "RT2880 Root File System not defined"
 #endif
+#endif
 
 extern int prom_argc;
 extern int *_prom_argv;
Index: linux-2.6.36/drivers/mtd/ralink/ralink_bbu_spi.c
===================================================================
--- linux-2.6.36.orig/drivers/mtd/ralink/ralink_bbu_spi.c
+++ linux-2.6.36/drivers/mtd/ralink/ralink_bbu_spi.c
@@ -37,6 +37,35 @@
 #endif
 #include "../maps/ralink-flash.h"
 
+#if 1 // openwrt test
+
+static struct mtd_partition rt2880_partitions[] = {
+    {
+                name:           "ALL",
+                size:           MTDPART_SIZ_FULL,
+                offset:         0,
+    },
+    /* Put your own partition definitions here */
+    {
+                name:           "Bootloader",
+                size:           MTD_BOOT_PART_SIZE,
+                offset:         0,
+    }, {
+                name:           "Config",
+                size:           MTD_CONFIG_PART_SIZE,
+                offset:         MTDPART_OFS_APPEND
+    }, {
+                name:           "Factory",
+                size:           MTD_FACTORY_PART_SIZE,
+                offset:         MTDPART_OFS_APPEND
+    }, {
+                name:           "firmware",
+                size:           0x800000,
+                offset:         0x50000,
+    }
+};
+
+#else
 
 static struct mtd_partition rt2880_partitions[] = {
 	{
@@ -93,6 +122,9 @@ static struct mtd_partition rt2880_parti
         }
 };
 
+#endif /* openwrt test */
+
+
 //#define TEST_CS1_FLASH
 //#define RD_MODE_DIOR
 
Index: linux-2.6.36/drivers/mtd/nand/partition.h
===================================================================
--- linux-2.6.36.orig/drivers/mtd/nand/partition.h
+++ linux-2.6.36/drivers/mtd/nand/partition.h
@@ -54,6 +54,39 @@ extern unsigned int  CFG_BLOCKSIZE;
 /* NAND PARTITION Mapping                                                  */
 /*=======================================================================*/
 //#ifdef CONFIG_MTD_PARTITIONS
+
+#if 1 /* openwrt test */
+
+static struct mtd_partition g_pasStatic_Partition[] = {
+	{
+                name:           "ALL",
+                size:           MTDPART_SIZ_FULL,
+                offset:         0,
+        },
+        /* Put your own partition definitions here */
+        {
+                name:           "Bootloader",
+                size:           MTD_BOOT_PART_SIZE,
+                offset:         0,
+        }, {
+                name:           "Config",
+                size:           MTD_CONFIG_PART_SIZE,
+                offset:         MTDPART_OFS_APPEND
+        }, {
+                name:           "Factory",
+                size:           MTD_FACTORY_PART_SIZE,
+                offset:         MTDPART_OFS_APPEND
+		}, {
+				name:			"firmware",
+				size:			0x800000,
+                offset:			0x140000, 
+		}
+};
+
+
+#else /* openwrt test */
+
+
 static struct mtd_partition g_pasStatic_Partition[] = {
 	{
                 name:           "ALL",
@@ -110,6 +143,8 @@ static struct mtd_partition g_pasStatic_
 
 };
 
+#endif /* openwrt test */
+
 #define NUM_PARTITIONS ARRAY_SIZE(g_pasStatic_Partition)
 extern int part_num;	// = NUM_PARTITIONS;
 //#endif
Index: linux-2.6.36/drivers/mtd/nand/mtk_nand.c
===================================================================
--- linux-2.6.36.orig/drivers/mtd/nand/mtk_nand.c
+++ linux-2.6.36/drivers/mtd/nand/mtk_nand.c
@@ -4511,7 +4511,7 @@ int mtk_nand_probe()
 	g_pasStatic_Partition[5].size = IMAGE1_SIZE - (LARGE_MTD_BOOT_PART_SIZE + LARGE_MTD_CONFIG_PART_SIZE \
 			                    + LARGE_MTD_FACTORY_PART_SIZE + CONFIG_MTD_KERNEL_PART_SIZ);
 #ifdef CONFIG_ROOTFS_IN_FLASH_NO_PADDING
-#error "No code to handle this case in MTK NAND Driver.."
+	//#error "No code to handle this case in MTK NAND Driver.."
 #endif
 #else	//CONFIG_RT2880_ROOTFS_IN_RAM
 	g_pasStatic_Partition[4].size = IMAGE1_SIZE - (LARGE_MTD_BOOT_PART_SIZE + LARGE_MTD_CONFIG_PART_SIZE \
